####  动态空间管理

##### **静态空间管理**

* 内部数组所占物理空间的容量，若在向量的生命期内不允许调整，则称作静态空间管理策略。很遗憾，该策略的空间效率难以保证。一方面，既然容量固定，总有可能在此后的某一时刻，无法加入更多的新元素。即导致所谓的上溢（overflow）。注意，造成此类溢出的原因，并非系统不能提供更多的空间。另一方面反过来，即便愿意为降低这种风险而预留出部分空间，也很难在程序执行之前，明确界定一个合理的预留量。
  * 例如，若使用向量来记录网络访问日志，则由于插入操作远多于删除操作，必然频繁溢出。
* **向量实际规模**与**其内部数组容量**的比值（即_size/_capacity），亦称作**装填因子**（load factor），它是衡量空间利用率的重要指标。保证向量的装填因子既不致于超过1，也不致于太接近于0。
* **可扩充向量**   经过一段时间的生长，每当身体无法继续为其外壳所容纳，蝉就会蜕去外壳，同时换上一身更大的外壳。扩充向量（extendable vector）的原理，与之相仿。若内部数组仍有空余，则操作可照常执行。每经一次插入（删除），可用空间都会减少（增加）一个单元（图2.1(a)）。一旦可用空间耗尽，就动态地扩大内部数组的容量。
* **如何实现扩容？新的容量取作多少才算适宜？**
  * 直接在原有物理空间的基础上追加空间
    * 这并不现实。数组特有的定址方式要求，物理空间必须地址连续，而我们却无法保证，其尾部总是预留了足够空间可供拓展。 
  * 要另行申请一个容量更大的数组
    * 将原数组中的成员集体搬迁至新的空间，此后方可顺利地插入新元素而不致溢出。当然，原数组所占的空间，需要及时释放并归还操作系统。
* 实际上，在调用insert()接口插入新元素之前，都要先调用扩容算法，检查内部数组的可用容量。一旦当前数据区已满（_size == _capacity），则将原数组替换为一个更大的数组。
* 新数组的地址由操作系统分配，与原数据区没有直接的关系

**分摊分析**

**时间代价**

与常规数组实现相比，可扩充向量更加灵活：只要系统尚有可用空间，其规模将不再受限于

初始容量。不过，这并非没有代价每次扩容，元素的搬迁都需要花费额外的时间。

准确地，每一次由n到2n的扩容，都需要花费*O*(2n) = *O*(n)时间这也是最坏情况下，

单次插入操作所需的时间。表面看来，这一扩容策略似乎效率很低，但这不过是一种错觉。

请注意，按照此处的约定，每花费*O*(n)时间实施一次扩容，数组的容量都会加倍。这就意

味着，至少要再经过n次插入操作，才会因为可能溢出而再次扩容。也就是说，随着向量规模的

不断扩大，在执行插入操作之前需要进行扩容的概率，也将迅速降低。故就某种平均意义而言，

用于扩容的时间成本不至很高。以下不妨就此做一严格的分析。

**分摊复杂度**

这里，不妨考查对可扩充向量的足够多次连续操作，并将其间所消耗的时间，分摊至所有的操作。如此分摊平均至单次操作的时间成本，称作分摊运行时间（amortized running time）。请注意，这一指标与平均运行时间（average running time）有着本质的区别（习题[2-1]）。后者是按照某种假定的概率分布，对各种情况下所需执行时间的加权平均，故亦称作期望运行时间（expected running time）。而前者则要求，参与分摊的操作必须构成和来自一个真实可行的操作序列，而且该序列还必须足够地长。相对而言，分摊复杂度可以针对计算成本和效率，做出更为客观而准确的估计。比如在这里，在任何一个可扩充向量的生命期内，在任何足够长的连续操作序列中，以任何固定间隔连续出现上述最坏情况的概率均为0，故常规的平均复杂度根本不具任何参考意义。作为评定算法性能的 一种重要尺度。

**O(1)分摊时间**

以可扩充向量为例，可以考查对该结构的连续n次（查询、插入或删除等）操作，将所有操作中用于内部数组扩容的时间累计起来，然后除以n。只要n足够大，这一平均时间就是用于扩容处理的分摊时间成本。以下我们将看到，即便排除查询和删除操作而仅考查插入操作，在可扩充向量单次操作中，用于扩容处理的分摊时间成本也不过*O*(1)。

假定数组的初始容量为某一常数N。既然是估计复杂度的上界，故不妨设向量的初始规模也

为N即将溢出。另外不难看出，除插入操作外，向量其余的接口操作既不会直接导致溢出，也不会增加此后溢出的可能性，因此不妨考查最坏的情况，假设在此后需要连续地进行n次insert()操作，n >> N。首先定义如下函数：size(n) =连续插入n个元素后向量的规模; capacity(n) =连续插入n个元素后数组的容量; T(n) =为连续插入n个元素而花费于扩容的时间; 其中，向量规模从N开始随着操作的进程逐步递增，故有：size(n) = N + n既然不致溢出，故装填因子绝不会超过100%。同时，这里的扩容采用了“懒惰”策略只有在的确即将发生溢出时，才不得不将容量加倍因此装填因子也始终不低于50%.概括起来，始终应有：

size(n)  capacity(n) < 2∙size(n)

考虑到N为常数，故有：

capacity(n) = (size(n)) = (n)

容量以2为比例按指数速度增长，在容量达到capacity(n)之前，共做过(**log**2n)次扩容，

每次扩容所需时间线性正比于当时的容量（或规模），且同样以2为比例按指数速度增长。因此，

消耗于扩容的时间累计不过：

T(n) = 2N + 4N + 8N + ... + capacity(n) < 2∙capacity(n) = (n)

将其分摊到其间的连续n次操作，单次操作所需的分摊运行时间应为*O*(1)。 

**它扩容策略**

以上分析确凿地说明，基于加倍策略的动态扩充数组不仅可行，而且就分摊复杂度而言效率

也足以令人满意。当然，并非任何扩容策略都能保证如此高的效率。比如，早期可扩充向量多采

用另一策略：一旦有必要，则追加固定数目的单元。实际上，无论采用的固定常数多大，在最坏

情况下，此类数组单次操作的分摊时间复杂度都将高达(n)

**缩容**

导致低效率的另一情况是，向量的实际规模可能远远小于内部数组的容量。比如在连续的一系列操作过程中，若删除操作远多于插入操作，则装填因子极有可能远远小于100%，甚至非常接近于0。当装填因子低于某一阈值时，我们称数组发生了下溢（underflow）。尽管下溢不属于必须解决的问题，但在格外关注空间利用率的场合，发生下溢时也有必要适当缩减内部数组容量。

可见，每次删除操作之后，一旦空间利用率已降至某一阈值以下，该算法随即申请一个容量减半的新数组，将原数组中的元素逐一搬迁至其中，最后将原数组所占空间交还操作系统。这里以25%作为装填因子的下限，但在实际应用中，为避免出现频繁交替扩容和缩容的情况，可以选用更低的阈值，甚至取作0（相当于禁止缩容）。

与expand()操作类似，尽管单次shrink()操作需要线性量级的时间，但其分摊复杂度亦为O(1)。实际上shrink()过程等效于expand()的逆过程，这两个算法相互配合，在不致实质地增加接口操作复杂度的前提下，保证了向量内部空间的高效利用。当然，就单次扩容或缩容操作而言，所需时间的确会高达(n)，因此在对单次操作的执行速度极其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。











