* 通过前面的章节，我们已经了解了一些基本的数据结构。根据其实现方式，这些数据结构大致可以分为两种类型：**基于数组的实现与基于链表的实现**。正如我们已经看到的，就其效率而言，二者各有长短。具体来说，**前一实现方式允许我们通过下标或秩，在常数的时间内找到目标对象；然而，一旦需要对这类结构进行修改，那么无论是插入还是删除，都需要耗费线性的时间。反过来，后一实现方式允许我们借助引用或位置对象，在常数的时间内插入或删除元素；但是为了找出居于特定次序的元素，我们却不得不花费线性的时间，对整个结构进行遍历查找**。能否将这两类结构的优点结合起来，并回避其不足呢？
* 在此前介绍的这些结构中，元素之间都存在一个自然的线性次序，故它们都属于所谓的**线性结构（linear structure）**。树则不然，其中的元素之间并不存在天然的直接后继或直接前驱关系。不过，正如我们马上就要看到的，只要附加某种约束（比如遍历），也可以在树中的元素之间确定某种线性次序，因此树属于**半线性结构（semi-linear structure）**。
* 树结构有着不计其数的变种，在算法理论以及实际应用中，它们都扮演着最为关键的角色。之所以如此，是因得益于其独特而又普适的逻辑结构。**树是一种分层结构**，而层次化这一特征几乎蕴含于所有事物及其联系当中，成为其本质属性之一。从文件系统、互联网域名系统和数据库系统，一直到地球生态系统乃至人类社会系统，层次化特征以及层次结构均无所不在。

#### 二叉树及其表示

##### 树 

* 从图论的角度看，**树等价于连通无环图**。
* 与一般的图相同，树也由一组**顶点（vertex）**以及联接与其间的若干条**边（edge）**组成。
* 在计算机科学中，往往还会在此基础上，再指定某一特定顶点，并称之为**根（root）**。在指定根节点之后，我们也称之为**有根树（rooted tree）**。此时，从程序实现的角度，我们也更多地将顶点称作**节点（node）**。

* **深度与层次**
  * 由树的**连通性**，每一节点与根之间都有一条路径相联；
  * 根据树的**无环性**，由根通往每个节点的路径必然唯一；
  * 沿每个节点 v 到根 r 的唯一通路所经过边的数目，称作**v的深度（depth）**，记作depth(v)。**依据深度排序**，可对所有节点做**分层归类**。特别地，约定根节点的深度 depth(r) = 0，故属于第0层。
* **祖先、后代与子树**
  * 任一节点v在通往树根沿途所经过的每个节点都是其**祖先（ancestor）**，v是它们的**后代（descendant）**。特别地，v的祖先/后代包括其本身，而v本身以外的祖先 /后代称作**真祖先（proper ancestor）**/ **真后代（proper descendant）**。
  * 节点v历代祖先的层次，自下而上以1为单位逐层递减；**在每一层次上，v的祖先至多一个**。特别地，若节点u 是v的祖先且恰好比v高出一层，则称u是v的**父亲（parent）**，v是u的**孩子（child）**。
  * v的孩子总数，称作其度数或度（degree），记作deg(v)。**无孩子的节点称作叶节点（leaf）**，**包括根在内的其余节点皆为内部节点**（internal node）。
  * v所有的后代及其之间的联边称作**子树（subtree）**，记作subtree(v)。
* **高度**
  * **树 T 中所有节点深度的最大值称作该树的高度（height）**，记作height(T)。
  * 树的高度总是由其中某一叶节点的深度确定的
  * 约定，仅含单个节点的树高度为 0，空树高度为 -1
  * **任一节点 v 所对应子树subtree(v)的高度，亦称作该节点的高度**，记作height(v)。特别地，全树的高度亦即其根节点r的高度，height(T) =height(r)。
* **二叉树**
  * 二叉树（binary tree）中每个节点的度数均不超过2。
  * 在二叉树中，同一父节点的孩子都可以左、右相互区分。此时，亦称作**有序二叉树（ordered binary tree）**。
  * 不含一度节点的二叉树称作**真二叉树（proper binary tree）** 
* **多叉树**
  * 一般地，树中各节点的孩子数目并不确定。**每个节点的孩子均不超过 k 个的有根树**，称作**k叉树（k-ary tree）**。

##### 树及其表示

* **父节点**
  * 在多叉树中，根节点以外的任一节点有且仅有一个父节点。
  * 将各节点组织为向量或列表，其中**每个元素除保存节点本身的信息（data）外，还需要保存父节点（parent）的秩或位置**。可为树根指定一个虚构的父节点-1或NULL，以便统一判断。
  * 空间方面： 所有向量或列表所占的空间总量 为*O*(n)，线性正比于节点总数n。
  * 时间方面：仅需常数时间，即可确定任一节点的父节点；但反过来，孩子节点的查找却不得不花费 O(n) 时间访遍所有节点。 
* **孩子节点**
  * 若注重孩子节点的快速定位，可**令各节点将其所有的孩子组织为一个向量或列表**。如此，对于拥有 r 个孩子的节点，可在 O(r + 1) 时间内列举出其所有的孩子。
* **父节点 +孩子节点**
  * 上父节点表示法和孩子节点表示法各有所长，但也各有所短
  * 令各节点既记录父节点，同时也维护一个序列以保存所有孩子。
  * 如此可以高效地兼顾对父节点和孩子的定位
  * 在节点插入与删除操作频繁的场合，为动态地维护和更新树的拓扑结构，不得不反复地遍历和调整一些节点所对应的孩子序列。然而，向量和列表等线性结构的此类操作都需耗费大量时间，势必影响到整体的效率。 
*  **有序多叉树=二叉树**
  * 尽管二叉树只是多叉树的一个子集，但其对应用问题的描述与刻画能力绝不低于后者。实际上以下我们还将进一步发现，即便是就计算效率而言，二叉树也并不逊色于一般意义上的树。反过来，得益于其定义的简洁性以及结构的规范性，二叉树所支撑的算法往往可以更好地得到描述，更加简捷地得到实现。
  * 为了保证作为多叉树特例的二叉树有足够的能力表示任何一棵多叉树，我们只需给多叉树增加一项约束条件， **同一节点的所有孩子之间必须具有某一线性次序**。仿照有序二叉树的定义，凡符合这一条件的多叉树也称**作有序（ordered tree）**。
* **长子+兄弟**
  * 有序多叉树中任一非叶节点都有唯一的“长子”，而且从该“长子”出发，可按照预先约定或指定的次序遍历所有孩子节点。
  * 为每个节点设置两个指针，分别指向其“长子”和下一“兄弟”。若将这两个指针分别与二叉树节点的左、右孩子指针统一对应起来，则可进一步地将原有序多叉树转换为的常规二叉树。

##### **编码树**

* 通讯理论中的一个基本问题是，如何在尽可能低的成本下，以尽可能高的速度，尽可能忠实地实现信息在空间和时间上的复制与转移。在现代通讯技术中，无论采用电、磁、光或其它任何形式，在信道上传递的信息大多以二进制比特的形式表示和存在，而**每一个具体的编码方案都对应于一棵二叉编码树**。
*  **二进制编码**
  * 在加载到信道上之前，信息被转换为二进制形式的过程称作**编码**（encoding）
  * 经信道抵达目标后再由二进制编码恢复原始信息的过程称作**解码**（decoding）
  * 编码和解码的任务分别由发送方和接收方分别独立完成，故在开始通讯之前，双方应已经以某种形式，就编码规则达成过共同的约定或协议。
  * **生成编码表**
    * 原始信息的基本组成单位称作字符，它们都来自于某一特定的有限集合 A，也称作字符集 （alphabet）。
    * 而以二进制形式承载的信息，都可表示为来自编码表 r = { 0, 1 }*的某一特定二进制串。
    * 每一**编码表都是从字符集 A 到编码表 r 的一个单射**，编码就是对信息文本中各字符逐个实施这一映射的过程，而解码则是逆向映射的过程。
    * 编码表一旦制定，信息的发送方与接收方之间也就建立起了一个约定与默契，从而使得独立的编码与解码成为可能。
  * 现在，所谓编码就是对于任意给定的文本，通过查阅编码表逐一将其中的字符转译为二进制编码，这些编码依次串接起来即得到了全文的编码。
* **二进制解码**
  * 由编码器生成的二进制流经信道送达之后，接收方可以按照事先约定的编码表，依次扫描各比特位，并经匹配逐一转译出各字符，从而最终恢复出原始的文本。
  * **解码歧义**
    * 编码方案确定之后，尽管编码结果必然确定，但解码过程和结果却不见得唯一。按照给定的编码表，有时甚至还会出现无法完成解码的情况。
  * **前缀无歧义编码**
    * 解码过程之所以会出现上述歧义甚至错误，根源在于编码表制订不当。
    * 解码算法采用的是，按顺序对信息比特流做子串匹配的策略，因此为消除匹配的歧义性，**任何两个原始字符所对应的二进制编码串，相互都不得是前缀**。
    * 只要各字符的编码串互不为前缀，则即便出现无法解码的错误，也绝对不致歧义。这类编码方案即所谓的“前缀无歧义编码”（prefix-free code），简称PFC编码。此类编码算法，可以**明确地将二进制编码串，分割为一系列与各原始字符对应的片段，从而实现无歧义的解码**。得益于这一特点，此类算法在整个解码过程中，对信息比特流的扫描不必回溯。
* **二叉编码树**
  * **根通路与节点编码**
    * 任一编码方案都可描述为一棵二叉树：从根节点出发，每次向左（右）都对应于一个0（1）比特位。于是由从根节点到每个节点的唯一通路，可以为各节点 v 赋予一个互异的二进制串，称作根通路串（root path string），记作 rps(v)。当然，|rps(v)| = depth(v) 就是v的深度。
    * 若将字符集中的字符分别映射至二叉树的节点，则字符 x 的二进制编码串即可取作rps(v(x))
