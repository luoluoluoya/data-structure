#### 计算机与算法
* 计算机是人类从事计算的工具，是抽象计算模型的具体物化。基于图灵模型的现代计算机，既是人类现代文明的标志与基础，更是人脑思维的拓展与延伸。
* 尽管计算机的性能日益提高，但这种能力在解决实际应用问题时能否真正得以发挥，决定性的关键因素仍在于人类自身。
* 通过深入思考与分析获得对问题本质的透彻理解，按照长期积淀而成的框架与模式设计出合乎问题内在规律的算法，选用、改进或定制足以支撑算法高效实现的数据结构，并在真实的应用环境中充分测试、调校和改进，构成了应用计算机高效求解实际问题的典型流程与不二法门。
* 1946年问世的ENIAC开启了现代电子数字计算机的时代，计算机科学（computer science）也在随后应运而生。**计算机科学的核心在于研究计算方法与过程的规律，而不仅仅是作为计算工具的计算机本身**，因此E. Dijkstra及其追随者更倾向于将这门科学称作计算科学（computing science）。
* 人类使用不同工具从事计算的历史可以追溯到更为久远的时代，计算以及计算工具始终与我们如影相随地穿越漫长的时光岁月，不断推动人类及人类社会的进化发展。从最初颜色各异的贝壳、长短不一的刻痕、周载轮回的日影、粗细有别的绳结，以至后来的直尺、圆规和算盘，都曾经甚至依然是人类有力的计算工具。
  * 用于支持和实现计算过程的物理机制，亦即广义的计算机。
    * 古埃及人的绳索
    * 欧几里得的尺规

##### 起泡排序

* D. Knuth曾指出，四分之一以上的CPU时间都用于执行同一类型的计算：按照某种约定的次序，将给定的一组元素顺序排列，比如将n个整数按通常的大小次序排成一个非降序列。这类操作统称排序（sorting）。

* 就广义而言，我们今天借助计算机所完成的计算任务中，有更高的比例都可归入此类。例如，从浩如烟海的万维网中找出与特定关键词最相关的前100个页面，就是此类计算的一种典型形式。排序问题在算法设计与分析中扮演着重要的角色，以下不妨首先就此做一讨论。为简化起见，这里暂且只讨论对整数的排序。

* **局部有序与整体有序**

  * 在由一组整数组成的序列A[0, n - 1]中，满足 A[i - 1]  <= A[i] 的相邻元素称作顺序的；否则是逆序的。不难看出，有序序列中每一对相邻元素都是顺序的，亦即,对任意1 <= i < n都有A[i - 1] <= A[i]；反之，所有相邻元素均顺序的序列，也必然整体有序。

* **扫描交换**

  * 由有序序列的上述特征，我们可以通过**不断改善局部的有序性实现整体的有序**：从前向后依次检查每一对相邻元素，一旦发现逆序即交换二者的位置。对于长度为n的序列，共需做n - 1次比较和不超过n - 1次交换，这一过程称作一趟扫描交换。

* **起泡排序**

  * 经过一趟扫描，序列未必达到整体有序。果真如此，则可对该序列再做一趟扫描交换，直到在序列中不再含有任何逆序的相邻元素。多数的这类交换操作，都会使得越小（大）的元素朝上（下）方移动（，直至它们抵达各自应处的位置。
  * 排序过程中，所有元素朝各自最终位置亦步亦趋的移动过程，犹如气泡在水中的上下沉浮，起泡排序（bubblesort）算法也因此得名。

* **整数数组癿起泡排序算法实现**

  ```c
  void swap(int *a, int *b)
  {
      int tmp = *a;
      *a = *b;
      *b = tmp;
  }
  
  void bubblesort1A(int * arr, int num)
  {
      unsigned short sorted = 0;  //整体排序标志，首先假定尚未排序
      while (!sorted) { //在尚未确讣已全尿排序乀前，逐趟迕行扫描交换
          sorted = 1; //假定已经排序
          for (int i = 1; i < num; ++i) {  //自左向右逐对检查弼前范围A[0, n)内癿各相邻元素
              if (*(arr+i-1) > *(arr+i)) {  //一旦A[i - 1]不A[i]逆序，则交换
                  sorted = 0;   //因整体排序丌能保证，需要清除排序标志
                  swap(arr+i-1, arr+i); 
              }
          }
          num--;
      }
  }
  ```

* **算法**

* 究竟什么是算法呢？

  * 所谓算法，是指基于特定的计算模型，旨在解决某一信息处理问题而设计的一个指令序列。
    * 比如，针对“过直线上一点作垂直线”这一问题，基于由绳索和奴隶构成的计算模型，由古埃及人设计的古埃及人的绳索算法；
    * 针对“三等分线段”这一问题，基于由直尺和圆规构成的计算模型，由欧几里得设计的欧几里得的尺规算法；
    * 针对“将若干元素按大小排序”这一问题，基于图灵机模型而设计的bubblesort1A()算法，等等。

* 算法还应必须具备要素

  * 输入与输出

    * 待计算问题的任一实例，都需要以某种方式交给对应的算法，对所求解问题特定实例的这种描述统称为输入（input）
    * 经计算和处理之后得到的信息，即针对输入问题实例的答案，称作输出（output）
    * 在物理上，输出有可能存放于单独的存储空间中，也可能直接存放于原输入所占的存储空间中

  * 基本操作、确定性与可行性

    * 所谓确定性和可行性是指，算法应可描述为由若干语义明确的基本操作（基本操作的适当组合）组成的指令序列，且每一基本操作在对应的计算模型中均可兑现

    * 从现代程序设计语言的角度，可以更加便捷而准确地理解算法的确定性与可行性。具体地，一个算法满足确定性与可行性，当且仅当它可以通过程序设计语言精确地描述，比如，起泡排序算法可以具体地描述和实现为代码中的函数bubblesort1A()，其中“读取某一元素的内容”、“修改某一元素的容”、“比较两个元素的大小”、“逻辑表达式求值”以及“根据逻辑判断确定分支转向”等等，都属于现代电子计算机所支持的基本操作。

  * 有穷性与正确性

    * 不难理解，任意算法都应在执行有限次基本操作之后终止并给出输出，此即所谓算法的有穷性（finiteness）。
    * 算法不仅应该迟早会终止，而且所给的输出还应该能够符合由问题本身在事先确定的条件，此即所谓算法的正确性（correctness）。
    * 证明算法有穷性和正确性的一个重要技巧，就是从适当的角度审视整个计算过程，并找出其所具有的某种不变性和单调性。
      * 单调性通常是指，问题的有效规模会随着算法的推进不断递减。
      * 不变性则不仅应在算法初始状态下自然满足，而且应与最终的正确性相呼应。当问题的有效规模缩减到0时，不变性应随即等价于正确性。

  * 退化与鲁棒性

    * 同一问题往往不限于一种算法，而同一算法也常常会有多种实现方式，因此除了以上必须具备的基本属性，在应用环境中还需从实用的角度对不同算法及其不同版本做更为细致考量和取舍。这些细致的要求尽管应纳入软件工程的范畴，但也不失为成熟算法的重要标志。
      * 比如其中之一就是，除一般性情况外，实用的算法还应能够处理各种极端的输入实例。仍以排序问题为例，极端情况下待排序序列的长度可能不是正数（参数n = 0甚至n < 0），或者反过来长度达到或者超过系统支持的最大值（n = INT_MAX），或者arr[]中的元素不见得互异甚至全体相等，以上种种都属于所谓的退化（degeneracy）情况。算法所谓的鲁棒性（robustness），就是要求能够尽可能充分地应对此类情况。

  * 重用性

    * 从实用角度评判不同算法及其不同实现方式时，可采用的另一标准是：算法的总体框架能否便捷地推广至其它场合。
      * 以起泡排序为例。实际上，起泡算法的正确性与所处理序列中元素的类型关系不大，无论是对于float、char或其它类型，只要元素之间可以比较大小，算法的整体框架就依然可以沿用。算法模式可推广并适用于不同类型基本元素的这种特性，即是重用性的一种典型形式。很遗憾，代码所实现的bubblesort1A()算法尚不满足这一要求；

* **起泡排序分析**

  * 在起泡交换的过程中，尽管多数时候元素会朝着各自的最终位置不断靠近，但有的时候某些元素也的确会暂时朝着远离自己应处位置的方向移动
  * 每经过一趟扫描交换，尽管并不能保证序列立即达到整体有序，但从“待求解问题的规模”这一角度来看，整体的有序性必然有所改善。以全局最大的元素为例，在第一趟扫描交换的过程中，一旦触及该元素，它必将与后续的所有元素依 次交换。经过第一趟扫描之后，该最大元素必然就位；而且在此后的各趟扫描交换中，该元素将绝不会参与任何交换。这就意味着，经过一趟扫描交换之后，我们只需 要关注前面更小的那n - 1个元素。实际上，这一结论对后续的各趟扫描交换也都成立。 于是，起泡排序算法的不变性和单调性可分别概括为：经过k趟扫描交换之后，最大的前 k个元素必然就位；经过 k 趟扫描交换之后，待求解问题的有效规模将缩减至 n - k。
  * 反观如bubblesort1A()算法代码所示的，外层while循环会不断缩减待排序序列的有效长度n。现在我们已经可以理解，该算法之所以能够如此处理，正是基于以上不变性和单调性。特别地，初始状态下 k = 0，这两条性质都自然满足。另一方面，由以上单调性可知，无论如何，至多经n - 1趟扫描交换后，问题的有效规模必将缩减至1。此时，仅含单个元素的序列，有序性不言而喻；而由该算法的不变性，其余 n - 1 个元素在此前的 n - 1 步迭代中业已相继就位。因此，算法不仅必然终止，而且输出序列必然整体有序，其有穷性与正确性由此得证。

* **算法效率**
  * **可计算性**
    * 学习程序设计语言的目的，在于学会如何编写合法（即合乎特定程序语言的语法）的程序，从而保证编写的程序或者能够经过编译和链接生成执行代码，或者能够由解释器解释执行。然而从通过计算有效解决实际问题的角度来看，这只是第一个层次，仅仅做到语法正确还远远不够。很遗憾，算法所应具备的更多基本性质，合法的程序并非总是自然具备。
    * 以前面提到的有穷性为例，完全合乎语法的程序却往往未必能够满足。相信每一位编写过程序的读者都有过这样的体验：很多合法的程序可以顺利编译链接，但在实际运行的过程中却因无穷循环或递归溢出导致异常。更糟糕的是，就大量的应用问题而言，根本就不可能设计出必然终止的算法。从这个意义讲，它们都属于不可解的问题。
  * **难解性**
    * 实际上我们不仅需要确定，算法对任何输入都能够在有穷次操作之后终止，而且更加关注该过程所需的时间。很遗憾，很多算法即便满足有穷性，但在终止之前所花费的时间成本却太高。
  * **计算效率**
    * 更多地关注于非“不可解和难解”的一般性问题，并讨论如何高效率地解决这一层面的计算问题。为此，首先需要确立一种尺度，用以从时间和空间等方面度量算法的计算成本，进而依此尺度对不同算法进行比较和评判。当然，更重要的是研究和归纳算法设计与实现过程中的一般性规律与技巧，以编写出效率更高、能够处理更大规模数据的程序。
  * **数据结构**
    * 无论是算法的初始输入、中间结果还是最终输出，在计算机中都可以数据的形式表示。对于数据的存储、组织、转移及变换等操作，不同计算模型和平台环境所支持的具体形式不尽相同，其执行效率将直接影响和决定算法的整体效率。数据结构这一学科正是以“数据”这一信息的表现形式为研究对象，旨在建立支持高效算法的数据信息处理策略、技巧与方法。要做到根据实际应用需求自如地设计、实现和选用适当的数据结构，必须首先对算法设计的技巧以及相应数据结构的特性了然于心。
  * 