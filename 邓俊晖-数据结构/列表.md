### 列表

#### 从向量到列表

* 向量结构中，各数据项的物理存放位置与逻辑次序完全对应，故可通过秩直接访问对应的元素，此即所谓“**循秩访问**”（call-by-rank）。
* 列表，与向量同属序列结构的范畴，其中的元素也构成一个线性逻辑次序；但与向量极为不同的是，元素的物理地址可以任意。为保证对列表元素访问的可行性，逻辑上互为前驱和后继的元素之间，应维护某种**索引关系**。这种索引关系，可抽象地理解为**被索引元素的位置（position）**，故列表元素是“**循位置访问**”的；也可形象地理解为通往被索引元素的链接（link），故亦称作“**循链接访问**”（call-by-link）。
* 向量中的秩同时对应于逻辑和物理次序，而位置仅对应于逻辑次序。
* 不同数据结构内部的存储与组织方式各异，其操作接口的使用方式及时空性能也不尽相同。在设计或选用数据结构时，应从实际应用的需求出发，先确定功能规范及性能指标。比如，引入列表结构的目的，就在于弥补向量结构在解决某些应用问题时，在功能及性能方面的不足。二者之间的差异，表面上体现于对外的操作方式，但根源则在于其内部存储方式的不同。
* **从静态到动态**
  * 数据结构支持的操作
    * 静态：仅从中获取信息
    * 动态：会修改数据结构的局部甚至整体。
  * **静态存储**策略: 各元素物理地址连续
  * 基于数组实现的向量结构为例，其size()和get()等静态操作均可在常数时间内完成，而insert()和remove()等动态操作却都可能需要线性时间. 得益于静态存储策略，可在*O*(1)时间内由秩确定向量元素的物理地址；但反过来，在添加（删除）元素之前（之后），又不得不移动*O*(n)个后继元素。可见，尽管如此可使静态操作的效率达到极致，但就动态操作而言，局部的修改可能引起大范围甚至整个数据结构的调整。
  * 列表（list）结构尽管也要求**各元素在逻辑上具有线性次序，但对其物理地址却未作任何限制** --- 此即所谓“**动态存储**”策略。
    * 在其生命期内，此类数据结构将随着内部数据的需要，相应地分配或回收局部的数据空间。如此，元素之间的逻辑关系得以延续，却不必与其物理次序相关。作为补偿，此类结构将通过指针或引用等机制，来确定各元素的实际物理地址。
    * 例如，链表（linked list）就是一种典型的动态存储结构。其中的数据，分散为一系列称作节点（node）的单位，节点之间通过指针相互索引和访问。为了引入新节点或删除原有节点，只需在局部，调整少量相关节点之间的指针。这就意味着，采用动态存储策略，至少可以大大降低动态操作的成本。

* **由秩到位置**

  * 改用以上动态存储策略之后，在提高动态操作效率的同时，却又不得不舍弃原静态存储策略中循秩访问的方式，从而造成静态操作性能的下降。以采用动态存储策略的线性结构（比如链表）为例。尽管按照逻辑次序，每个数据元素依然具有秩这一指标，但为了访问秩为r的元素，我们只能顺着相邻元素之间的指针，从某一端出发逐个扫描各元素，经过r步迭代后才能确定该元素的物理存储位置。这意味着，原先只需*O*(1)时间的静态操作，此时的复杂度也将线性正比于被访问元素的秩，在最坏情况下等于元素总数n；即便在各元素被访问概率相等的情况下，平均而言也需要*O*(n)时间。
  * 对数据结构的访问方式，应与其存储策略相一致。此时，既然继续延用循秩访问的方式已非上策，就应更多地习惯于通过位置，来指代并访问动态存储结构中的数据元素。与向量中秩的地位与功能类似，列表中的位置也是指代各数据元素的一个标识性指标，借助它可以便捷地（比如在常数时间内）得到元素的物理存储地址。各元素的位置，通常可表示和实现为联接于元素之间的指针或引用。因此，基于此类结构设计算法时，应更多地借助逻辑上相邻元素之间的位置索引，以实现对目标元素的快速定位和访问，并进而提高算法的整体效率。

* **列表**

  * 与向量一样，列表也是由具有线性逻辑次序的一组元素构成的集合： L = { a0, a1, ..., an-1 }; 列表是链表结构的一般化推广，其中的元素称作节点（node），分别由特定的位置或链接指代。与向量一样，在元素之间，也可定义前驱、直接前驱，以及后继、直接后继等关系；相对于任意元素，也有定义对应的前缀、后缀等子集。 

* **接口**

  * 作为列表的基本组成单位，列表节点除需保存对应的数据项，还应记录其前驱和后继的位置，故需将这些信息及相关操作组成列表节点对象，然后参与列表的构建。

* **列表节点**

  * **ADT接口**

    ```
    操 作 接 口 		功 能
    data() 			当前节点所存数据对象
    pred() 			当前节点前驱节点的位置
    succ() 			当前节点后继节点的位置
    insertAsPred(e) 插入前驱节点，存入被引用对象e，返回新节点位置
    insertAsSucc(e) 插入后继节点，存入被引用对象e，返回新节点位置
    ```

  * **ListNode模板类**

    ```c++
    typedef int Rank;
    #define ListNodePosi(T) ListNode<T>*
    
    /**
        每个节点都存有数据对象data。为保证叙述简洁，在不致歧义的前提下，本书将不再区分
        节点及其对应的data对象。此外，每个节点还设有指针pred和succ，分别指向其前驱和后继。
        为了创建一个列表节点对象，只需根据所提供的参数，分别设置节点内部的各个变量。其中
        前驱、后继节点的位置指针若未予指定，则默认取作NULL
     */
    template <typename T> class ListNode{
    private:
        T data;                 //数值
        ListNodePosi(T) pred;   // 前驱
        ListNodePosi(T) succ;   // 后继
    public:
        ListNode();
        ListNode(T, ListNodePosi(T), ListNodePosi(T));
        ListNodePosi(T) insertAsPred ( T const& e );
        ListNodePosi(T) insertAsSucc ( T const& e );
    };
    ```

* **列表**

  * **ADT接口**

    ```
    操 作 接 口 		功 能 				适 用 对 象
    size() 		报告列表弼前癿觃模（节点总数） 		列表
    first()、last() 	迒回首、末节点癿位置 			   列表
    insertAsFirst(e)
    insertAsLast(e) 将e弼作首、末节点揑入 列表
    insertA(p, e)
    insertB(p, e) 将e弼作节点p癿直接后继、前驱揑入 列表
    remove(p) 初除位置p处癿节点，迒回其数值 列表
    disordered() 刞断所有节点是否已按非降序排列 列表
    sort() 调整各节点癿位置，使乀按非降序排列 列表
    find(e) 查找目标元素e，失败时迒回NULL 列表
    search(e) 查找目标元素e，迒回丌大亍e且秩最大癿节点 有序列表
    deduplicate() 剔除重复节点 列表
    uniquify() 剔除重复节点 有序列表
    traverse() 遍历幵统一处理所有节点，处理斱法由函数对象指定 列表
    // 请留意用以指示插入和删除操作位置的节点p。这里约定，它或者在此前经查找已经确定
    ```

  *  **列表模板类**

    ```c++
    
    ```

#### 列表

* **头、尾节点**		
  * List对象的内部组成及逻辑结构如图3.1所示，其中私有的头节点（header）和尾节点（trailer）始终存在，但对外并不可见。对外部可见的数据节点如果存在，则其中的第一个和最后一个节点分别称作首节点（first node）和末节点（last node）。
  * 就内部结构而言，头节点紧邻于首节点之前，尾节点紧邻于末节点之后。这类经封装之后从外部不可见的节点，称作**哨兵节点**（sentinel node）。
    * 设置哨兵节点之后，对于从外部可见的任一节点而言，其前驱和后继在列表内部都必然存在，故可简化算法的描述与实现。
    * 哨兵节点的引入，也使得相关算法不必再对各种边界退化情况做专门的处理，从而避免出错的可能
    * 尽管哨兵节点也需占用一定的空间，但只不过是常数规模，其成本远远低于由此带来的便利。
* **由秩到位置的转换**
  * 鉴于偶尔可能需要通过秩来指定列表节点，可通过重载操作符“[]”,提供一个转换接口。
  * 为将任意指定的秩r转换为列表中对应的元素，可从首节点出发，顺着后继指针前进r步。只要秩r合法，该算法的正确性即一目了然。其中每步迭代仅需常数时间，故该算法的总体运行时间应为*O*(r + 1)，线性正比于目标节点的秩。相对于向量同类接口的*O*(1)复杂度，列表的这一效率十分低下其根源在于，列表元素的存储和访问方式已与向量截然不同。诚然，当r大于n/2时，从trailer出发沿pred指针逆行查找，可以在一定程度上减少迭代次数，但就总体的平均效率而言，这一改进并无实质意义。
* **查找**
* **插入**

#### 有序列表

* 若列表中所有节点的逻辑次序与其大小次序完全一致，则称作有序列表（sorted list）。
* 为保证节点之间可以定义次序，依然假定元素类型T直接支持大小比较，或已重载相关操作符。与有序向量一致地，这里依然约定采用非降次序。
* **唯一化**
  * 与有序向量同理，有序列表中的雷同节点也必然（在逻辑上）彼此紧邻