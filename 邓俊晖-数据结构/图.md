* 相互之间均可能存在二元关系的一组对象，从数据结构的角度分类，属于**非线性结构（non-linear structure）**
* 此类一般性的二元关系，属于图论（Graph Theory）的研究范畴。从算法的角度对此类结构的处理策略，与树相仿，也是通过遍历将其转化为半线性结构，进而借助树结构已有的处理方法和技巧，最终解决问题。

#### 概述

* 图结构是描述和解决实际应用问题的一种基本而有力的工具。所谓的图（graph），可定义为G = (V, E)。其中，集合V中的元素称作顶点（vertex）；集合E中的元素分别对应于V中的 某一对顶点(u, v)，表示它们之间存在某种关系，故亦称作边（edge）。一种直观显示图结构的方法是，用小圆圈或小方块代表顶点，用联接于其间的直线段或曲线弧表示对应的边。
* 从计算的需求出发，我们约定V和E均为有限集，通常将其规模分别记 n = |V| 和 e = |E|。
* **无向图、有向图及混合图**
  * 若边(u, v)所对应顶点u和v的次序无所谓，则称作无向边（undirected edge），例如表示同学关系的边。反之若u和v不对等，则称(u, v)为有向边（directed edge），例如描述企 业与银行之间的借贷关系，或者程序之间的相互调用关系的边。
  * 如此，无向边(u, v)也可记作(v, u)，而有向的(u, v)和(v, u)则不可混淆。这里约定，有向边(u, v)从u指向v，其中u称作该边的起点（origin）或尾顶点（tail），而v称作该边的终点（destination）或头顶点（head）。 
  * 若E中各边均无方向，则G称作无向图（undirected graph，简称undigraph）。反之，若E中只含有向边，则G称作有向图（directed graph，简称 digraph）。特别地，若E同时包含无向边和有向边，则G称作混合图（mixed graph），对应地可分别描述为无向边和有向边。
  * 相对而言，有向图的通用性更强，因为无向图和混合图都可转化为有向图，每条无向边(u, v)都可等效地替换为对称的一对有向边(u, v)和(v, u)。
* **度**
  * 对于任何边e = (u, v)，称顶点u和v彼此邻接（adjacent），互为邻居；而它们都与边e彼此关联（incident）。在无向图中，与顶点v关联的边数，称作v的度数（degree），记作deg(v)。 
  * 对于有向边e = (u, v)，e称作u的出边（outgoing edge）、v的入边（incoming edge）。 v的出边总数称作其出度（out-degree），记作outdeg(v)；入边总数称作其入度（in-degree），记作indeg(v)。
* **简单图**
  * 联接于同一顶点之间的边，称作自环（self-loop）。在某些特定的应用中，这类边可能的确具有意义。比如在城市交通图中，沿着某条街道，有可能不需经过任何交叉路口即可直接返回原处。不含任何自环的图称作简单图（simple graph）
* **通路与环路**
  * 所谓路径或通路（path），就是由m + 1个顶点与m条边交替而成的一个序列： p = { v0, e1, v1, e2, v2, ..., em, vm }，且对任何0 < i <= m都有 ei = (vi-1, vi)。也就是说，这些边依次地首尾相联。其中沿途边的总数m，亦称作通路的长度，记作|p| = m。为简化描述，也可依次给出通路沿途的各个顶点，而省略联接于其间的边，即表示为：p = { v0, v1, v2, ..., vm }
  * 尽管通路上的边必须互异，但顶点却可能重复。
  * 沿途顶点互异的通路，称作简单通路（simple  path）。
  * 特别地，对于长度 m >= 1的通路 p，若起止顶点相同（即v0 = vm），则称作环路（cycle），其长度也取作沿途边的总数。反之，不含任何环路的有向图，称作有向无环图（directed acyclic graph, DAG）。
  * 尽管环路上的各边必须互异，但顶点却也可能重复。反之若沿途除v0 = vm外所有顶点均互异，则称作简单环路（simple cycle）。
  * 经过图中各边一次且恰好一次的环路，称作欧拉环路（Eulerian tour）。当然，其长度也恰好等于图中边的总数e。 
  * 经过图中各顶点一次且恰好一次的环路，称作哈密尔顿环路（Hamiltonian tour），其长度亦等于构成环路的边数。
* **带权网络**
  * 图不仅需要表示顶点之间是否存在某种关系，有时还需要表示这一关系的具体细节。
  * 为适应这类应用要求，需通过一个权值函数，为每一边e指定一个权重（weight），比如wt(e)即为边e的权重。各边均带有权重的图，称作带权图（weighted graph）或带权网络（weighted network），有时也简称网络（network），记作G(V, E, wt())。 
* **复杂度**
* 与其它算法一样，图算法也需要就时间性能和空间性能，进行分析和比较。相应地，问题的输入规模，也应该以顶点数与边数的总和（n + e）来度量。
* 对于无向图，每一对顶点至多贡献一条边，故总共不超过n(n - 1)/2条边，且这个上界由完全图达到。对于有向图，每一对顶点都可能贡献（互逆的）两条边，因此至多可有n(n - 1)条边。总而言之，必有e = *O*(n^2)。

#### 抽象数据类型



#### 邻接矩阵

* **原理**

  * 邻接矩阵（adjacency matrix）是图ADT最基本的实现方式，使用方阵A\[n][n]表示由n个顶点构成的图，其中每个单元，各自负责描述一对顶点之间可能存在的邻接关系，故此得名。
  * 对于无权图，存在（不存在）从顶点u到v的边，当且仅当A\[u][v] = 1（0）。
  * 这一表示方式，不难推广至带权网络。此时，矩阵各单元可从布尔型改为整型或浮点型，记录所对应边的权重。对于不存在的边，通常统一取值为 无穷大 或0。

* **实现**

  ```
  
  ```
  * 部将所有顶点组织为一个向量V[]；同时通过嵌套定义，将所有（潜在的）边组织为一个二维向量E\[][]亦即邻接矩阵。

* **时间性能**

  * 各顶点的编号可直接转换为其在邻接矩阵中对应的秩，从而使得图ADT中所有的静态操作接口，均只需*O*(1)时间, 这主要是得益于向量“循秩访问”的特长与优势。另外，边的静态和动态操作也仅需*O*(1)时间, 其代价是邻接矩阵的空间冗余。
  * 然而，这种方法并非完美无缺。其不足主要体现在，顶点的动态操作接口均十分耗时。为了插入新的顶点，顶点集向量V[]需要添加一个元素；边集向量E[][]也需要增加一行，且每行都需要添加一个元素。顶点删除操作，亦与此类似。不难看出，这些恰恰也是向量结构固有的不足。好在通常的算法中，顶点的动态操作远少于其它操作。而且，即便计入向量扩容的代价，就分摊意义而言，单次操作的耗时亦不过*O*(n)

* **空间性能**

  * 上述实现方式所用空间，主要消耗于邻接矩阵，亦即其中的二维边集向量E[][]。每个Edge对象虽需记录多项信息，但总体不过常数。
  * 当然，对于无向图而言，仍有改进的余地。如图6.5(a)所示，无向图的邻接矩阵必为对称阵，其中除自环以外的每条边，都被重复地存放了两次。也就是说，近一半的单元都是冗余的。为消除这一缺点，可采用压缩存储等技巧，进一步提高空间利用率。

#### 邻接表

* **原理**

  * 即便就有向图而言，O(n2) 的空间亦有改进的余地。实际上，如此大的空间足以容纳所有潜在的边。然而实际应用所处理的图，所含的边通常远远少于O(n2)。比如在平面图之类的稀疏图（sparse graph）中，边数渐进地不超过O(n)，仅与顶点总数大致相当
  * 由此可见，邻接矩阵的空间效率之所以低，是因为其中大量单元所对应的边，通常并未在图中出现。
  * 可分别记录各顶点的关联边（或等价地，邻接顶点）。这些列表，也因此称作邻接表（adjacency list）。实际上，这种通用方法不难推广至有向图

* **复杂度**

  * 邻接表所含列表数等于顶点总数n，每条边在其中仅存放一次（有向图）或两次（无向图），故空间总量为*O*(n + e)，与图自身的规模相当，较之邻接矩阵有很大改进。
  * 当然，空间性能的这一改进，需以某些方面时间性能的降低为代价。比如，为判断顶点v到 u的联边是否存在，exists(v, u)需在v对应的邻接表中顺序查找，共需*O*(n)时间。
  * 与顶点相关操作接口，时间性能依然保持，甚至有所提高。比如，顶点的插入操作，可在 O(1)而不是O(n)时间内完成。当然，顶点的删除操作，仍需遍历所有邻接表，共需O(e)时间。
  * 尽管邻接表访问单条边的效率并不算高，却十分擅长于以批量方式，处理同一顶点的所有关联边。在以下图遍历等算法中，这是典型的处理流程和模式。比如，为枚举从顶点v发出的所有边，现在仅需$\Theta(1 + outDegree(v))$而非$\Theta(n)$时间。故总体而言，邻接表的效率较之邻接矩阵更高。

* **实现**

  ```
  
  ```

#### 图遍历算法

* 图算法是个庞大的家族，其中大部分成员的主体框架，都可归结于图的遍历。与树 的遍历类似，图的遍历也需要访问所有顶点一次且仅一次；此外，图遍历同时还需要访问所有的边一次且仅一次, 尽管对树而言这显而易见, 并对边做分类，以便后续的处理。
* 实际上，无论采用何种策略和算法，图的遍历都可理解为，将非线性结构转化为半线性结构的过程。经遍历而确定的边类型中，最重要的一类即所谓的树边，它们与所有顶点共同构成了原图的一棵支撑树（森林），称作遍历树（traversal tree）。以遍历树为背景，其余各种类型的边，也能提供关于原图的重要信息，比如其中所含的环路等。
* 图中顶点之间可能存在多条通路，故为避免对顶点的重复访问，在遍历的过程中，通常还要动态地设置各顶点不同的状态，并随着遍历的进程不断地转换状态，直至最后的“访问完毕”。图的遍历更加强调对处于特定状态顶点的甄别与查找，故也称作图搜索（graph search）。
* 与树遍历一样，作为图算法基石的图搜索，本身也必须能够高效地实现。

##### 广度优先搜索

* **策略**

  * 各种图搜索之间的区别，体现为边分类结果的不同，以及所得遍历树（森林）的结构差异。其决定因素在于，搜索过程中的每一步迭代，将依照何种策略来选取下一接受访问的顶点。

  * 通常，都是选取某个已访问到的顶点的邻居。同一顶点所有邻居之间的优先级，在多数遍历中不必讲究。因此，实质的差异应体现在，当有多个顶点已被访问到，应该优先从谁的邻居中选取下一顶点。比如，广度优先搜索（breadth-first search, BFS）采用的策略，可概括为：**越早被访问到的顶点，其邻居越优先被选用**。 于是，始自图中顶点s的BFS搜索，将首先访问顶点s；再依次访问s所有尚未访问到的邻居； 再按后者被访问的先后次序，逐个访问它们的邻居；...；如此不断。在所有已访问到的顶点中，仍有邻居尚未访问者，构成所谓的波峰集（frontier）。于是，BFS搜索过程也可等效地理解为：

    **反复从波峰集中找到最早被访问到顶点v，若其邻居均已访问到，则将其逐出波峰集；否则，随意选出一个尚未访问到的邻居，并将其加入到波峰集中**

  * 若将上述BFS策略应用于树结构，则效果等同于层次遍历。波峰集内顶点的深度始终相差不超过一，且波峰集总是优先在更浅的层次沿广度方向拓展。实际上，树层次遍历的这些特性，在一定程度上也适用于图的BFS搜索
  * 由于每一步迭代都有一个顶点被访问，故至多迭代*O*(n)步。另一方面，因为不会遗漏每个刚被访问顶点的任何邻居，故对于无向图必能覆盖s所属的连通分量（connected component），对于有向图必能覆盖以s为起点的可达分量（reachable component）。倘若还有来自其它连通分量或可达分量的顶点，则不妨从该顶点出发，重复上述过程。

* **实现**

  ```c++
  
  ```

  * 算法的实质功能，由子算法BFS()完成。对该函数的反复调用，即可遍历所有连通或可达域。
  * 仿照树的层次遍历，这里也借助队列Q，来保存已被发现，但尚未访问完毕的顶点。因此，任何顶点在进入该队列的同时，都被随即标记为DISCOVERED（已发现）状态。
  * BFS()的每一步迭代，都先从Q中取出当前的首顶点v；再逐一核对其各邻居u的状态并做相应处理；最后将顶点v置为VISITED（访问完毕）状态，即可进入下一步迭代。
  * 若顶点u尚处于UNDISCOVERED（未发现）状态，则令其转为DISCOVERED状态，并随即加入队列Q。实际上，每次发现一个这样的顶点u，都意味着遍历树可从v到u拓展一条边。于是，将 边(v, u)标记为树边（tree edge），并按照遍历树中的承袭关系，将v记作u的父节点。
  * 若顶点u已处于DISCOVERED状态（无向图），或者甚至处于VISITED状态（有向图），则意味着边(v, u)不属于遍历树，于是将该边归类为跨边（cross edge）

  * BFS()遍历结束后，所有访问过的顶点通过parent[]指针依次联接，从整体上给出了原图某一连通或可达域的一棵遍历树，称作广度优先搜索树，或简称BFS树（BFS tree）。
  * 各次BFS()调用所得的BFS树构成一个森林，称作BFS森林（BFS forest）。

* **复杂度**

  * 除作为输入的图本身外，BFS搜索所使用的空间，主要消耗在用于维护顶点访问次序的辅助队列、用于记录顶点和边状态的标识位向量，累计*O*(n) + *O*(n) + *O*(e) = *O*(n + e)。
  * 时间方面，首先需花费*O*(n + e)时间复位所有顶点和边的状态。不计对子函数BFS()的调用，bfs()本身对所有顶点的枚举共需*O*(n)时间。而在对BFS()的所有调用中，每个顶点、每条边均只耗费*O*(1)时间，累计*O*(n + e)。综合起来，BFS搜索总体仅需*O*(n + e)时间。

* **应用**

  * 基于BFS搜索，可有效地解决连通域分解、最短路径等问题。

##### 深度优先搜索

* **策略**

  * 深度优先搜索（Depth-First Search, DFS）选取下一顶点的策略，可概括为：**优先选取最后一个被访问到的顶点的邻居**。于是，以顶点s为基点的DFS搜索，将首先访问顶点s；再从s所有尚未访问到的邻居中任取其一，并以之为基点，递归地执行DFS搜索。故各顶点被访问到的次序，类似于树的先序遍历；而**各顶点被访问完毕的次序，则类似于树的后序遍历**

* **实现**

  ```c++
  
  ```

  * 算法的实质功能，由子算法DFS()递归地完成。每一递归实例中，都先将当前节点v标记为DISCOVERED（已发现）状态，再逐一核对其各邻居u的状态并做相应处理。待其所有邻居均已处理完毕之后，将顶点v置为VISITED（访问完毕）状态，便可回溯。
  * 若顶点u尚处于UNDISCOVERED（未发现）状态，则将边(v, u)归类为树边（tree edge），并将v记作u的父节点。此后，便可将u作为当前顶点，继续递归地遍历。
  * 若顶点u处于DISCOVERED状态，则意味着在此处发现一个有向环路。此时，在DFS遍历树中u必为v的祖先，故应将边(v, u)归类为后向边（back edge）。
  * 这里为每个顶点v都记录了被发现的和访问完成的时刻，对应的时间区间[dTime(v), fTime(v)]均称作v的活跃期（active duration）。实际上，任意顶点v和u之间是否存在祖先/后代的“血缘”关系，完全取决于二者的活跃期是否相互包含。
  * 活跃期相互包含的顶点，在DFS树中都是“祖先-后代”关系。这种对应关系并非偶然，籍此可以便捷地判定节点之间的承袭关系。故无论是对DFS搜索本身，还是对基于DFS的各种算法而言，时间标签都至关重要。
  * 对于有向图，顶点u还可能处于VISITED状态。此时，只要比对v与u的活跃期，即可判定在DFS树中v是否为u的祖先。若是，则边(v, u)应归类为前向边（forward edge）；否则，二者必然来自相互独立的两个分支，边(v, u)应归类为跨边（cross edge）。
  * DFS(s)返回后，所有访问过的顶点通过parent[]指针依次联接，从整体上给出了顶点s所属连通或可达分量的一棵遍历树，称作深度优先搜索树或DFS树（DFS tree）。与BFS搜索一样，此时若还有其它的连通或可达分量，则可以其中任何顶点为基点，再次启动DFS搜索。
  * 最终，经各次DFS搜索生成的一系列DFS树，构成了DFS森林（DFS forest）。

* **复杂度**

  * 除了原图本身，深度优先搜索算法所使用的空间，主要消耗于各顶点的时间标签和状态标记，以及各边的分类标记，二者累计不超过*O*(n) + *O*(e) = *O*(n + e)。
  * 当然，如采用直接递归实现方式，操作系统为维护运行栈还需耗费一定量的空间. 尽管这部分增量在渐进意义下还不足以动摇以上结论。为此，不妨通过显式地引入并维护一个栈结构，将DFS算法改写为迭代版本
  * 时间方面，首先需要花费*O*(n + e)时间对所有顶点和边的状态复位。不计对子函数DFS()的调用，dfs()本身对所有顶点的枚举共需*O*(n)时间。不计DFS()之间相互的递归调用，每个顶点、每条边只在子函数DFS()的某一递归实例中耗费*O*(1)时间，故累计亦不过*O*(n + e)时间。综合而言，深度优先搜索算法也可在*O*(n + e)时间内完成。

* **应用**

  * 深度优先搜索无疑是最为重要的图遍历算法。基于DFS的框架，可以导出和建立大量的图算法。与广度优先搜索一样，深度优先搜索也可用作连通分量的分解，或者有向无环图的判定

###### 拓扑排序

* 知同一有向图的拓扑排序未必唯一。

* 有向无环图的拓扑排序必然存在；反之亦然。这是因为，有向无环图对应于偏序关系，而拓扑排序则对应于全序关系。在顶点数目有限时，与任一偏序相容的全序必然存在。

* 实际上，在任一有限偏序集中，必有极值元素（尽管未必唯一）；相应地，任一有向无环图，也必包含入度为零的顶点。否则，每个顶点都至少有一条入边，这意味着图中包含环路。

* 于是，只要将入度为0的顶点m（及其关联边）从图G中取出，则剩余的G'依然是有向无环图，故其拓扑排序也必然存在。从递归的角度看，一旦得到了G'的拓扑排序，只需将m作为最大顶点插入，即可得到G的拓扑排序。如此，我们已经得到了一个拓扑排序的算法

* **算法**

  * 不妨将关注点，转至与极大顶点相对称的极小顶点。
  * 同理，有限偏序集中也必然存在极小元素（同样，未必唯一）。该元素作为顶点，出度必然为零。而在对有向无环图的DFS搜索中，首先因访问完成而转换至 VISITED 状态的顶点 m，也必然具有这一性质；反之亦然。
  * 进一步地，根据DFS搜索的特性，顶点m（及其关联边）对此后的搜索过程将不起任何作用。于是，下一转换至VISITED状态的顶点可等效地理解为是，从图中剔除顶点m（及其关联边）之后的出度为零者。 在拓扑排序中，该顶点应为顶点m的前驱。由此可见，DFS搜索过程中各顶点被标记为VISITED的次序，恰好（按逆序）给出了原图的一个拓扑排序。
  * 此外，DFS搜索善于检测环路的特性，恰好可以用来判别输入是否为有向无环图。具体地，搜索过程中一旦发现后向边，即可终止算法并报告“因非DAG而无法拓扑排序”。
  * 因多个极大、极小元素（入度、出度为零顶点）并存而导致拓扑排序的不唯一性并未消除，而是转由该算法对每趟DFS起点的选择策略决定。

  ```
  
  ```

* **复杂度**
  * 这里仅额外引入的栈，规模不超过顶点总数*O*(n)。总体而言，空间复杂度与基本的深度优先搜索算法同样，仍为*O*(n + e)。该算法的递归跟踪过程与标准DFS搜索完全一致，且各递归实例自身的执行时间依然保持为*O*(1)，故总体运行时间仍为*O*(n + e)。

###### 双连通域分解

* 考查无向图G。若删除顶点v后G所包含的连通域增多，则v称作切割节点（cut vertex）或关节点（articulation point）。反之，不含任何关节点的图称作双连通图。任一无向图都可视作由若干个极大的双连通子图组合而成，这样的每一子图都称作原图的一个双连通域（bi-connected component）。
* 较之其它顶点，关节点更为重要。在网络系统中它们对应于网关，决定子网之间能否连通。故在资源总量有限的前提下，找出关节点并重点予以保障，是提高系统整体稳定性和鲁棒性的基本策略。

* **关节点蛮力算法**

  * 由其定义，可直接导出蛮力算法大致如下：首先，通过BFS或DFS搜索统计出图G所含连通域的数目；然后逐一枚举每个顶点v，暂时将其从图G中删去，并再次通过搜索统计出图G\{v}所含连通域的数目。于是，顶点v是关节点，当且仅当图G\{v}包含的连通域多于图G。这一算法需执行n趟搜索，耗时*O*(n(n + e))，如此低的效率无法令人满意。

    ```
    
    ```

    

* **DFS树分析**

  * 经DFS搜索生成的DFS树，表面上看似乎“丢失”了原图的一些信息，但实际上就某种意义而言，依然可 以提供足够多的信息。比如，DFS树中的叶节点，绝不可能是原图中的关节点，此类顶点的删除既不致影响DFS树的连通性，也不致影响原图的连通性。此外，DFS树的根节点若至 少拥有两个分支，则必是一个关节点。反之，若根节点仅有一个分支，则与叶节点同理，它也不可能是关节点。
  * 经DFS搜索生成的DFS树的内部节点C。若节点C的移除导致其某一棵（比如以D为根的）真子树与其真祖先（比如A）之间无法连通，则C必为关节点。反之，若C的所有真子树都能与C的某一真祖先连通，则C就不可能是关节点。**内部节点C是关节点，当且仅当C的某棵极大真子树不（经后向边）联接到C的真祖先**。
  * 当然，在原无向图的DFS树中，C的真子树只可能通过后向边与C的真祖先连通。因此，只要在DFS搜索过程记录并更新各顶点v所能（经由后向边）连通的最高祖先（highest connected ancestor, HCA）hca[v]，即可及时认定关节点，并报告对应的双连通域。

* **可行算法**

  ```
  
  ```

* **复杂度**
  * 与基本的DFS搜索算法相比，这里只增加了一个规模*O*(n)的辅助栈，故整体空间复杂度仍为 O(n + e)。时间方面，尽管同一顶点v可能多次入栈，但每一次重复入栈都对应于某一新发现的双连通域，与之对应地必有至少另一顶点出栈且不再入栈。因此，这类重复入栈操作不会超过n 次，入栈操作累计不超过2n次，故算法的整体运行时间依然是*O*(n + e)。

#### 优先级搜索

* **优先级与优先级数**

  * 以上图搜索应用虽各具特点，但其基本框架却颇为相似。总体而言，都需通过迭代逐一发现各顶点，将其纳入遍历树中并做相应处理，同时根据应用问题的需求，适时给出解答。各算法在功能上的差异，主要体现为每一步迭代中对新顶点的选取策略不同。比如，BFS搜索会优先考查更早被发现的顶点，而DFS搜索则恰好相反，会优先考查最后被发现的顶点。
  * 每一种选取策略都等效于，给所有顶点赋予不同的优先级，而且随着算法的推进不断调整； 而每一步迭代所选取的顶点，都是当时的优先级最高者。按照这种理解，包括BFS和DFS在内的几乎所有图搜索，都可纳入统一的框架。鉴于优先级在其中所扮演的关键角色，故亦称作优先级搜索（priority-first search, PFS），或最佳优先搜索（best-first search, BFS）。
  * 在实际应用中，引导优化方向的指标，往往对应于某种有限的资源或成本（如光纤长度、通讯带宽、机票价格等），故这里不妨约定优先级数越大（小）顶点的优先级越低（高）。相应地，在算法的初始化阶段，通常都将顶点的优先级数统一置为最大（比如对于int类型，可采用INT_MAX）, 或等价地，优先级最低。

* **基本算法框架**

  ```
  
  ```

* **复杂度**
  * PFS搜索由两重循环构成，其中内层循环又含并列的两个循环。若采用邻接表实现方式，同时假定prioUpdater()只需常数时间，则前一内循环的累计时间应取决于所有顶点的出度总和，即*O*(e)；后一内循环固定迭代n次，累计*O*(n2）时间。两项合计总体复杂度为*O*(n2)。实际上，借助稍后第10章将要介绍的优先级队列等结构，PFS搜索的效率还有进一步提高的余地

##### 最小支撑树

* **支撑树**

  * 连通图G的某一无环连通子图T若覆盖G中所有的顶点，则称作G的一棵支撑树或生成树（spanning tree）。 
  * 就保留原图中边的数目而言，支撑树既是“禁止环路”前提下的极大子图，也是“保持连通”前提下的最小子图。
  * 在实际应用中，原图往往对应于由一组可能相互联接（边）的成员（顶点）构成的系统，而支撑树则对应于该系统最经济的联接方案。确切地，尽管同一幅图可能有多棵支撑树，但由于其中的顶点总数均为n，故其采用的边数也均为n - 1。

* **最小支撑树**

  * 若图G为一带权网络，则每一棵支撑树的成本（cost）即为其所采用各边权重的总和。在G的所有支撑树中，成本最低者称作最小支撑树（minimum spanning tree, MST）。
  * 聚类分析、网络架构设计、VLSI布线设计等诸多实际应用问题，都可转化并描述为最小支撑树的构造问题。。在这些应用中，边的权重大多对应于某种可量化的成本，因此作为对应优化问题的基本模型，最小支撑树的价值不言而喻。另外，最小支撑树构造算法也可为一些NP问题提供足够快速、足够接近的近似解法。正因为受到来自众多应用和理论领域的需求推动，最小支撑树的构造算法也发展得较为成熟

* **歧义性**

  * 尽管同一带权网络通常都有多棵支撑树，但总数毕竟有限，故必有最低的总体成本。然而，总体成本最低的支撑树却未必唯一。
    * 以包含三个顶点的完全图为例，若三条边的权重相等，则其中任意两条边都构成总体成本最低的一棵支撑树。 
  * 当多棵支撑树的总体成本均达到最低。故严格说来，此类支撑树应称作极小支撑树（minimal spanning tree）。当然，通过强制附加某种次序即可消除这种歧义性，故不妨仍称之为最小支撑树。

* **蛮力算法**

  * 由最小支撑树的定义，可直接导出蛮力算法大致如下：逐一考查G的所有支撑树并统计其成本，从而挑选出其中的最低者。然而根据Cayley公式，由n个互异顶点组成的完全图共有$n^{n-2}$棵支撑树，即便忽略掉构造所有支撑树所需的成本，仅为更新最低成本的记录就需要$O(n^{n-2})$时间。

* **割与极短跨越边** 

  * 图G = (V; E)中，顶点集V的任一非平凡子集U及其补集V\U都构成G的一个割（cut），记作(U : V\U)。若边uv满足uU且vU，则称作该割的一条跨越边（crossing edge）。因此类边联接于V及其补集之间，故亦形象地称作该割的一座桥（bridge）。

* **Prim算法**

  * Prim算法的正确性基于以下事实：**最小支撑树总是会采用联接每一割的最短跨越边.**
    * 假设uv是割(U : V\U)的最短跨越边，而最小支撑树T并未采用该边。于是由树的连通性，在T中必有至少另一跨边st联接该割（有可能s = u或t = v，尽管二者不能同时成立）。同样由树的连通性，T中必有分别联接于u和s、v和t之间的两条通路。由于树是极大的无环图，故倘若将边uv加至T中，则必然出现穿过u、v、t 和s的唯一环路。接下来，只要再删除边st，则该环路必然随之消失。经过如此的一出一入，若设T转换为T'，则T'依然是连通图，且所含边数与T相同均为n - 1。这就意味着，T'也是原图的一棵支撑树。就结构而言，T'与T的差异仅在于边uv和边st，故二者的成本之差就是这两条边的权重之差。不难看出，边st的权重必然大于身为最短跨越边的uv， 故T'的总成本低于T这与T总体权重最小的前提矛盾。
  * 注意，以上性质并不意味着同一割仅能为最小支撑树贡献一条跨越边
  * **贪心迭代**
    * 由以上性质，可基于贪心策略导出一个迭代式算法。每一步迭代之前，假设已经得到最小支撑树T的一棵子树Tk = (Vk; Ek)，其中Vk包含k个顶点，Ek包含k - 1条边。于是，若将Vk及其补集视作原图的一个割，则在找到该割的最短跨越边ek = (vk, uk)（vk属于Vk且uk不属于Vk）之后，即可将Tk扩展为一棵更大的子树Tk+1 = (Vk+1; Ek+1)，其中Vk+1 = Vk U {uk}，Ek+1 = Ek U {ek}。最初的T1不含边而仅含单个顶点，故可从原图的顶点中任意选取。 
  *  **实现**

  ```
  
  ```

  * **复杂度**

    不难看出，以上顶点优先级更新器只需常数的运行时间，故由对优先级搜索算法性能的分析结论，以上Prim算法的时间复杂度为*O*(n^2)。作为PFS搜索的特例，Prim算法的效率也可借助优先级队列进一步提高

#####  最短路径