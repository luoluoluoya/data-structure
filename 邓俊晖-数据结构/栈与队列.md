### 栈与队列

* 与此前介绍的向量和列表一样，它们也属于线性序列结构，故其中存放的数据对象之间也具有线性次序。相对于一般的序列结构，栈与队列的数据操作范围仅限于逻辑上的特定某端。然而，得益于其简洁性与规范性，它们既成为构建更复杂、更高级数据结构的基础，同时也是算法设计的基本出发点，甚至常常作为标准配置的基本数据结构以硬件形式直接实现。因此无论就工程或理论而言，其基础性地位都是其它结构无法比拟的。
* 相对于向量和列表，栈与队列的外部接口更为简化和紧凑，故亦可视作向量与列表的特例

#### 栈

* **入栈与出栈**
  * 栈（stack）是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，故也可定义首、末元素。不过，尽管栈结构也支持对象的插入和删除操作，但其**操作的范围仅限于栈的某一特定端**。也就是说，若约定新的元素只能从某一端插入其中，则反过来也只能从这一端删除已有的元素。禁止操作的另一端，称作**盲端**
  * 栈中可操作的一端更多地称作**栈顶（stack top）**，而另一无法直接操作的盲端则更多地称作**栈底（stack bottom）**。
* **后进先出**
  * 关于栈操作位置的约定和限制不难看出，栈中元素接受操作的次序必然始终遵循所谓“**后进先出**”（last-in-first-out, LIFO）的规律：从栈结构的整个生命期来看，更晚（早）出栈的元素，应为更早（晚）入栈者；反之，更晚（早）入栈者应更早（晚）出栈。
* 既然栈可视作序列的特例，故只要将栈作为向量的派生类
  * 将向量的首/末端作为栈底/顶 （向量末端的动态操作效率较高）
  * 栈操作都限制于向量的末端，参与操作的元素没有任何后继

* 将栈作为列表的派生类

#### 栈与递归

* 递归算法所需的空间量，主要决定于最大递归深度。在达到这一深度的时刻，同时活跃的递归实例达到最多。
* 在Windows等大部分操作系统中，**每个运行中的二进制程序都配有一个调用栈（call stack）或执行栈（execution stack）**。借助调用栈可以跟踪属于同一程序的所有函数，记录它们之间的相互调用关系，并保证在每一调用实例执行完毕之后，可以准确地返回。
* **函数调用**
  * 调用栈的基本单位是**帧（frame）**。每次函数调用时，都会相应地创建一帧，记录该函数实例在二进制程序中的返回地址（return address），以及局部变量、传入参数等，并将该帧压入调用栈。
  * 若在该函数返回之前又发生新的调用，则同样地要将与新函数对应的一帧压入栈中，成为新的栈顶。函数一旦运行完毕，对应的帧随即弹出，运行控制权将被交还给该函数的上层调用函数，并按照该帧中记录的返回地址确定在二进制程序中继续执行的位置。
  * **在任一时刻，调用栈中的各帧，依次对应于那些尚未返回的调用实例，亦即当时的活跃函数实例（active function instance）**。特别地，位于栈底的那帧必然对应于入口主函数 main()， 若它从调用栈中弹出，则意味着整个程序的运行结束，此后控制权将交还给操作系统。
  * 仿照**递归跟踪法**，**程序执行过程出现过的函数实例及其调用关系，也可构成一棵树，称作该程序的运行树。任一时刻的所有活跃函数实例，在调用栈中自底到顶，对应于运行树中从根节点到最新活跃函数实例的一条调用路径。**此外，调用栈中各帧还需存放其它内容。比如，因各帧规模不一，它们还需记录前一帧的起始地址，以保证其出栈之后前一帧能正确地恢复。
* **递归**
  * 作为函数调用的特殊形式，递归也可借助上述调用栈得以实现。函数的自我调用，也会新压入一帧。可见，同一函数可能同时拥有多个实例，并在调用栈中各自占有一帧。这些帧的结构完全相同，但其中同名的参数或变量，都是独立的副本。
* **避免递归**
  * 今天，包括C++在内的各种高级程序设计语言几乎都允许函数直接或间接地自我调用，通过递归来提高代码的简洁度和可读性。而Cobol和Fortran等早期的程序语言虽然一开始并未采用栈来实现过程调用，但在其最新的版本中也陆续引入了栈结构来支持过程调用。
  * 尽管如此，系统在后台隐式地维护调用栈的过程中，难以区分哪些参数和变量是对计算过程有实质作用的，更无法以通用的方式对它们进行优化，因此**不得不将描述调用现场的所有参数和变量悉数入栈。再加上每一帧都必须保存的执行返回地址以及前一帧起始位置，往往导致程序的空间效率不高甚至极低**；同时，**隐式的入栈和出栈操作也会令实际的运行时间增加不少**。
  * 既然递归本身就是操作系统隐式地维护一个调用栈而实现的，我们自然也可以**通过显式地模拟调用栈的运转过程，实现等效的算法功能**。采用这一方式，程序员可以精细地裁剪栈中各帧的内容，从而尽可能降低空间复杂度的常系数。尽管算法原递归版本的高度概括性和简洁性将大打折扣，但毕竟在空间效率方面可以获得足够的补偿。

#### 栈的典型应用

* **逆序输出**

  * 在栈所擅长解决的典型问题中，有一类具有以下共同特征：首先，虽有明确的算法，但其**解答却以线性序列的形式给出**；其次，无论是递归还是迭代实现，**该序列都是依逆序计算输出的**；最后，**输入和输出规模不确定，难以事先确定盛放输出数据的容器大小**。因其特有的“后进先出”特性及其在容量方面的自适应性，使用栈来解决此类问题可谓恰到好处。

* **递归嵌套**

  * 具有自相似性的问题多可嵌套地递归描述，但因分支位置和嵌套深度并不固定，其递归算法的复杂度不易控制。栈结构及其操作天然地具有递归嵌套性，故可用以高效地解决这类问题。

  * **栈混洗**

    * 考查三个栈A、B和S。其中，B和S初始为空；A含有n个元素，自顶而下构成输入序列：A = < a1, a2, ..., an ]; 这里，分别用尖括号、方括号示意栈顶、栈底。以下，若只允许通过S.push( A.pop() )弹出栈A的顶元素并随即压入栈S中，或通过B.push( S.pop() )弹出S的顶元素并随即压入栈B中，则在经过这两类操作各n次之后，栈A和S有可能均为空，原A中的元素均已转入栈B。此时，若将B中元素自底而上构成的序列记作：B = [ ak1, ak2, ..., akn >则该序列称作原输入序列的一个**栈混洗（stack permutation）**。 	
    * 栈混洗并不唯一
    * 一般地对于长度为n的输入序列，每一栈混洗都对应于由栈 S 的 n 次push 和 n 次 pop 构成的某一合法操作序列。反之，由n次push和n次pop构成的任何操作序列，只要满足“**任一前缀中的push不少于pop**”这一限制，则该序列也必然对应于某个栈混洗

  * **括号匹配**

    * 对源程序的语法检查是代码编译过程中重要而基本的一个步骤，而对表达式括号匹配的检查则又是语法检查中必需的一个环节。其任务是，对任一程序块，判断其中的括号是否在嵌套的意义下完全匹配（简称匹配）。
  * 只要将push、pop操作分别与左、右括号相对应，则长度为 n 的栈混洗，必然与由n对括号组成的合法表达式彼此对应
  
  ```
    
  ```
  
  
  
* **延迟缓冲**
  
    * 在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算往往滞后于扫描的进度，需要待到必要的信息已完整到一定程度之后，才能作出判断并实施计算。在这类场合，栈结构则可以扮演数据缓冲区的角色。

  * **表达式求值**
  
    * 在编译C++程序的预处理阶段，源程序中的所有常量表达式都需首先计算并替换为对应的具体数值。而在解释型语言中，算术表达式的求值也需随着脚本执行过程中反复进行。
    * 表达式求值**不能简单地按照“先左后右”的次序执行表达式中的运算符**。关于运算符执行次序的规则（即运算优先级），一部分决定于**事先约定的惯例**（比如乘除优先于加减），**另一部分则决定于括号**。也就是说，仅根据表达式的某一前缀，并不能完全确定其中各运算符可否执行以及执行的次序；**只有在已获得足够多后续信息之后，才能确定其中哪些运算符可以执行**。
  
    ```
    
    ```
  
    
  
  * **逆波兰表达式**
  
    * 逆波兰表达式（reverse Polish notation, RPN）是数学表达式的一种，其语法规则可概括为：操作符紧邻于对应的（最后一个）操作数之后。
    * RPN表达式亦称作后缀表达式（postfix），原表达式则称作中缀表达式（infix）。波兰表达式称之为前缀表达式
    * RPN表达式中运算符的执行次序，可更为简捷地确定，既不必在事先做任何约定，更无需借助括号强制改变优先级。具体而言，各运算符被执行的次序，与其在RPN表达式中出现的次序完全吻合。
    * 只要RPN表达式合法，在整个求值计算的过程中，当前运算符所需的操作数无论多少，都必然恰好按次序存放在当前栈的顶部。
    * 运算符在RPN中所处的位置，恰好就是其对应的操作数均已就绪且该运算可以执行的位置。
  
    ```
    
    ```
  
    * **手工转换**
  
      ```
      
      ```
  
    * **自动转换**
  
      ```
      
      ```

#### 试探回溯法

* **试探与回溯**
  * **很多应用问题的解，在形式上都可看作若干元素按特定次序构成的一个序列**。以经典的旅行商问题（traveling salesman problem, TSP）为例，其目标是计算出由给定的n个城市构成的一个序列，使得按此序列对这些城市的环游成本（比如机票价格）最低。尽管此类问题本身的描述并不复杂，但遗憾的是，由于所涉及元素（比如城市）的每一排列都是一个候选解，它们往往构成一个极大的搜索空间。通常，其搜索空间的规模与全排列总数大体相当，为n! = *O*(nn)。因此若采用蛮力策略，逐一生成可能的候选解并检查其是否合理，则必然无法将运行时间控制在多项式的范围以内。
* **剪枝**
  * 为此，必须基于对应用问题的深刻理解，**利用问题本身具有的某些规律尽可能多、尽可能早地排除搜索空间中的候选解**。其中一种重要的技巧就是，根据候选解的某些局部特征，以候选解子集为单位批量地排除。**搜索空间多呈树状结构，而被排除的候选解往往隶属于同一分支，故这一技巧也可以形象地称作剪枝（pruning）。**
  * 与之对应的算法多呈现为如下模式。**从零开始，尝试逐步增加候选解的长度。更准确地，这一过程是在成批地考查具有特定前缀的所有候选解。这种从长度上逐步向目标解靠近的尝试，称作试探（probing）。作为解的局部特征，特征前缀在试探的过程中一旦被发现与目标解不合，则收缩到此前一步的长度，然后继续试探下一可能的组合。特 征 前 缀 长 度 缩 减 的 这 类 操 作 ， 称 作 回 溯（backtracking），其效果等同于剪枝**。如此，只要目标解的确存在就迟早会被发现，而且只要剪枝所依据的特征设计得当，计算的效率就会大大提高。
* 如何保证搜索过的部分不被重复搜索
  * 在剪枝的位置留下某种标记

#####  八皇后

* 国际象棋中皇后的势力范围覆盖其所在的水平线、垂直线以及两条对角线。现考查如下问题：在n*n的棋盘上放置n个皇后，如何使得她们彼此互不攻击. 此时称她们构成一个可行的棋局。对于任何整数n * 4，这就是n皇后问题。由鸽巢原理可知，在n行n列的棋盘上至多只能放置n个皇后。反之，n个皇后在n*n棋盘上的可行棋局通常也存在
* **算法实现**
* **迷宫寻径**
  * **问题描述**
  * 路径规划是人工智能的基本问题之一，要求依照约定的行进规则，在具有特定几何结构的空间区域内，找到从起点到终点的一条通路。以下考查该问题的一个简化版本：空间区域限定为由 n * n个方格组成的迷宫，除了四周的围墙，还有分布其间的若干障碍物；只能水平或垂直移动。我们的任务是，在任意指定的起始格点与目标格点之间，找出一条通路（如果的确存在）。



#### 队列

* **入队与出队**
  * 与栈一样，队列（queue）也是存放数据对象的一种容器，其中的数据对象也按线性的逻辑次序排列。队列结构同样支持对象的插入和删除，但两种操作的范围分别被限制于队列的两端。若约定新对象只能从某一端插入其中，则只能从另一端删除已有的元素。允许取出元素的一端称作**队头（front）**，而允许插入元素的另一端称作**队尾（rear）**。
  * 元素的插入与删除也是修改队列结构的两种主要方式，站在被操作对象的角度，分别称作**入队（enqueue）**和**出队（dequeue）**操作。
* **先进先出**
  * 由以上的约定和限制不难看出，与栈结构恰好相反，队列中各对象的操作次序遵循所谓先进先出（first-in-first-out, FIFO）的规律：更早（晚）出队的元素应为更早（晚）入队者，反之，更早（晚）入队者应更早（晚）出队。

* **ADT接口**

  ```
  
  ```

* **Queue模板类**

  * 队列也可视作序列的特例，故只要将队列作为列表的派生类

  ```
  
  ```

##### 队列应用

* **循环分配器**

  * 为在客户（client）群体中共享的某一资源（比如多个应用程序共享同一CPU），一套公平且高效的分配规则必不可少，而队列结构则非常适于定义和实现这样的一套分配规则.

  ```
  RoundRobin { //循环分配器
       Queue Q(clients); //参不资源分配癿所有客户组成队列Q
       while (!ServiceClosed()) { //在服务兲闭乀前，反复地
           e = Q.dequeue(); //队首癿客户出队，幵
           serve(e); //接叐服务，然后
           Q.enqueue(e); //重新入队
       } 
   }
  ```

  * 在以上所谓**轮值（round robin）**算法中，首先令所有参与资源分配的客户组成一个队列Q。接下来是一个反复轮回式的调度过程：取出当前位于队头的客户，将资源交予该客户使用；在经过固定的时间之后，回收资源，并令该客户重新入队。得益于队列“先进先出”的特性，如此既可在所有客户之间达成一种均衡的公平，也可使得资源得以充分利用。这里，每位客户持续占用资源的时间，对该算法的成败至关重要。一方面，为保证响应速度，这一时间值通常都不能过大。另一方面，因占有权的切换也需要耗费一定的时间，故若该时间值取得过小，切换过于频繁，又会造成整体效率的下降。因此，往往需要通过实测确定最佳值。反过来，在单一客户使用多个资源的场合，队列也可用以保证资源的均衡使用，提高整体使用效率。

* **银行服务模拟**