

##### 图的定义

* 在线性表中，数据元素之间是被串起来的，仅有线性关系，每个数据元素只有一 个直接前驱和一个直接后继。在树形结构中，数据元素之间有着明显的层次关系，并 且每一层上的数据元素可能和下一层中多个元素相关，但只能和上一层中一个元素相关。这和一对父母可以有多个孩子，但每个孩子却只能有一对父母是一个道理。可现实中，人与人之间关系就非常复杂，比如我认识的朋友，可能他们之间也互相认识， 这就不是简单的一对一、一对多，研究人际关系很自然会考虑多对多的情况。那就是 我们今天要研究的主题——图。图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

* 图(Graph )是由顶点的有穷非空集合和顶点之间边的集合组成，通 常表示为：G ( V,E ),其中，G表示一个图，V是图G中顶点的集 合，E是图G中边的集合。
  * 线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元 素，我们则称之为顶点（Vertex）。
  * 线性表中可以没有数据元素，称为空表。树中可以没有结点，叫做空树。在图结构中，不允许没有顶点。在图定义中，若 V 是顶 点的集合，则强调了顶点集合 V 有穷非空。
  * 线性表中，相邻的数据元素之间具有线性关系，树结构中，相邻两层的结点具有层次关系，而图中，任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的。
* 无向边：若顶点$v_i$到$v_j$之间的边没有方向，则称这条边为无向边（Edge）,用无 序偶对（vi, vj）来表示。如果图中任意两个顶点之间的边都是无向边，则称该图为无 向图（Undirected graphs） .
* 在图中，若不存在**顶点到其自身的边(环)**，且同一条**边不重复(一重边)**出现，则称这样的图为简单图。
* 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。含有n 个顶点的无向完全图有(n*(n-1)/2)条边。
* 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为 有向完全图。含有n个顶点的有向完全图有 n*(n-1) 条边
  * 对于具有 n 个顶点和 e 条边数的图，无向图 0< e < n (n -1) /2 ,有向图 0<e<n*(n-l).
* 有很少条边或弧的图称为稀疏图，反之称为稠密图。
* 有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权 (Weight). 这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为网(Network)。
* 假设有两个图G= (V, E)和G = (V'；E'),如果 $V'\sube V$且 $E' \sube E$,则称G'为G的子图。
* 对于无向图 G= (V,E) ,如果边 $(u，v) \in E$,则称顶点u和v互为邻接点 (Adjacent),即u和v邻接。边(u, v)依附(incident)于顶点u和v或者说 (u, v)与顶点u和v相关联。顶点v的度(Degree)是和v相关联的边的数目，记为 deg(v); 边数其实就是各顶点度数和的一半，多出的一半是因为 重复两次记数。
* 无向图G= (V, E)中从顶点v到顶点u的路径(Path)是一个顶点与边的交替序列。 如果G是有向图，则路径也是有向的。
* 树中根结点到任意结点的路径是唯一的，但是图中顶点与顶点之间的路径却是不 唯一的。
  * 树是不存在回路的简单联通图。
* 第一个顶点到最后一个顶点相同的路径称为回路或环(Cycle)。
* 序列中顶点不重复出现的路径称为简单路径。
* 除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。
* 在无向图G中，如果从顶点u到顶点V有路径，则称u和V是连通的。如果对于 图中任意两个顶点u和v都是连通的，则称G是连通图(Connected Graph)
* 无向图中的极大连通子图称为连通分量
  * 要是子图
  * 子图要是连通的
  * 连通子图含有极大顶点数
  * 具有极大顶点数的连通子图包含依附于这些顶点的所有边
* 所谓的一个连通图的生成树是一个极小的连通子图，它含有图中全部的n个顶 点，但只有足以构成一棵树的 n-1条边。
  * 如果一个图有n个顶 点和小于 n-1 条边，则是非连通图
  * 果它多于 n-1 边条，必定构成一个环，因为 这条边使得它依附的那两个顶点之间有了第二条路径

* 如果一个有向图恰有一个顶点的入度为0,其余顶点的入度均为1,则是一棵有向 树。对有向树的理解比较容易，所谓入度为0其实就相当于树中的根结点，其余顶点入 度为1就是说树的非根结点的双亲只有一个。

* 一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。

* 图的定义与术语总结

  * 图按照有无方向分为无向图和有向图。无向图由顶点和边构成，有向图由顶点和 弧构成。弧有弧尾和弧头之分。

  * 图按照边或弧的多少分稀疏图和稠密图。
  * 如果任意两个顶点之间都存在边叫完全 图，有向的叫有向完全图。若无重复的边或顶点到自身的边则叫简单图。
  * 图中顶点之间有邻接点、依附的概念。无向图顶点的边数叫做度，有向图顶点分为入度和出度。
  * 图上的边或弧上带权则称为网。
  * 图中顶点间存在路径，两顶点存在路径则说明是连通的，如果路径最终回到起始 点则称为环，当中不重复叫简单路径。若任意两顶点都是连通的，则图就是连通图， 有向则称强连通图。
  * 图中有子图，若子图极大连通则就是连通分量，有向的则称强连通分量。
  * 无向图中连通且n个顶点n-1条边叫生成树。有向图中一顶点入度为0其余顶 点入度为1的叫有向树。一个有向图由若干棵有向树构成生成森林。

---

##### 图的抽象数据类型

```
ADT 图(Graph )
Data
    顶点的有穷非空集合和边的集合。
Operation
    CreateGraph (*G, V, VR):按照顶点集V和边弧集VR的定义构造图G。 	 DestroyGraph ( *G)：图 G 存在则销毁。
    LocateVex(G,u):若图G中存在顶点u,则返回图中的位jt。
    GetVex(G,v):返回图G中顶点v的值。
    PutVex (G, v, value ):将图 G 中顶点 v 赋值 valueo
    FirstAdjVex ( G, *v ):返回顶点v的一个邻接顶点，若顶点在G中无邻接顶点返回空。
    NextAdjVex(Grvr*w):返回顶点v相对于顶点w的下一个邻接顶点，若w是v的最后 一个邻接点则返回“空” 
    InsertVex ( *G, v ):在图G中増添新顶点V。
    DeleteVex ( *G, v):删除图G中顶点v及其相关的弧。
    InsertArc ( *G, v, w ):在图G中増添弧<v,w>,若G是无向图，还需要増添对称弧<W,V>
    DeleteArc ( *G, v,w):在图G中删除弧<v,w>,若G是无向图，则还删除对称孤<W,V>
    DFSTraverse(G):对图G中进行深度优先遍历，在遍历过程对每个顶点调用。
    HFSTraverse ( G ):时图G中进行广度优先遍历，在遍历过程对每个顶点调用
endADT
```

---

##### 图的存储结构

* 图的存储结构相较线性表与树来说就更加复杂了。首先，我们口头上说的“顶点 的位置”或“邻接点的位置”只是一个相对的概念。其实从图的逻辑结构定义来看， 图上任何一个顶点都可被看成是第一个顶点，任一顶点的邻接点之间也不存在次序关系。
* 也正由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此**无法以数 据元素在内存中的物理位置来表示元素之间的关系**，也就是说，图不可能用简单的顺序存储结构来表示。而多重链表的方式，即以一个数据域和多个指针域组成的结点表示图中的一个顶点，尽管可以实现图结构，但其实在树中，我们也已经讨论过，这是有问题的。如果各个顶点的度数相差很大，按度数最大的顶点设计结点结构会造成很 多存储单元的浪费，而若按每个顶点自己的度数设计不同的顶点结构，又带来操作的不便。因此，对于图来说，如何对它实现物理存储是个难题

---

* **邻接矩阵**

  * 考虑到图是由顶点和边或弧两部分组成。合在一起比较困难，那就很自然地考虑 到分两个结构来分别存储。顶点不分大小、主次，所以用一个一维数组来存储是很不 错的选择。而边或弧由于是顶点与顶点之间的关系，一维搞不定，那就考虑用一个二 维数组来存储。于是我们的邻接矩阵的方案就诞生了。

  * 

  * 图的邻接矩阵存储方式是用两个数组来表示图。**一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。**
    $$
    a[i][j] = \begin{cases}
    1 & (i, j) \in E 或者 <i, j> \in E\\
    0 & (i, j) \notin E 
    \end{cases}
    $$

  * 主对角线表示（i， i）； 无向图的边数组是一个对称矩阵 (aij = aji)。

  * 通过矩阵，我们就可以知道的图中信息

    * 判定任意两顶点是否有边无边 $a[i][j] == 1$
    * 知道某个顶点的度. $\sum_j a[i][j] $ (其实就是这个顶点vi在邻接矩阵中第i行（或第i 列）的元素之和)
    * 求顶点vi的所有邻接点就是将矩阵中第i行元素扫描一遍，$a[i][j]$为1就是 邻接点。

  * 有向图，主对角线上数值依然为0,  但此矩阵并不对称

  * 有向图讲究入度与出度，顶点Vi的入度正好是第 i 列各数之和。顶点 vj的出度即第j行的各数之和。

  * 与无向图同样的办法，判断顶点vi到vj是否存在弧，只需要查找矩阵中$a[i][j] $是否为1即可。要求vi的所有邻接点就是将矩阵第 i 行元素扫描一遍，查找$a[i][j] $为1的顶点。

  * 设图G是网图，有n个顶点，则邻接矩阵是一个nxn的方阵，定义为：
    $$
    a[i][j] = \begin{cases}
    W_{ij} & 若(v_i, v_j) \in E 或 <v_i, v_j> \in E \\
    0 & 若 i = j \\
    \infty & 反之
    \end{cases}
    $$
    这里Wij表示(Vi,Vj)上的权值。$\infty$表示一个计算机允许的、大于所有边 上权值的值，也就是一个不可能的极限值。有同学会问，为什么不是0呢？原因在于 权值Wij大多数情况下是正值，但个别时候可能就是0,甚至有可能是负值。因此必须 要用一个不可能的值来代表不存在。

  * 邻接矩阵存储的结构

    ```
    typedef char VertexType; /*顶点类型应由用户定义*/
    typedef int EdgeType;  /*边上的权值类型应由用户定义*/
    #define MAXVEX 100  /*最大顶点数，应由用户定义*/
    #define INFINITY 65535  /*用65535来代表 无穷/
    
    typedef struct
    {
        VertexType vexs[MAXVEX];  /*顶点表*/
        EdgeType arc[MAXVEX](MAXVEX]; /*邻接矩阵，可看作边表*/
        int numvertexes, numEdges; /*图中当前的顶点数和边数*/
    } MGraph;
    // 有了这个结构定义，我们构造一个图, 其实就是给顶点表和边表输入数据的过程。
    ```

    ```
    /*建立无向网图的邻接矩阵表示*/
    void CreateMGraph ( MGraph *G )
    {
        int i,j, k, w;
        printf ("输入顶点数和边数：\n” );
        scanf ( "%d, %d", &G->numVertexes, &G->numEdges ) ;/* 输入顶点数和边教 */ 
        for ( i = 0; i < G->numVertexes; i++ )	/* 读入顶点信息，建立顶点表 * /
            scanf (&G->vexs[i]);
        for (i = 0;i <G->numVertexes;i++)
            for ( j = 0;j <G->numVertexes;j ++ )
            G->arc(i] (j]= INFINITY; /* 邻接矩阵初始化 */
        for (k = 0;k <G->numEdges;k++) /* 读入 numEdges 条边，建立邻接矩阵 */ (
            Printf ( ••输入边(vi.vj )上的下标i,下标j和权w:\n");
            scanf (n%dr%d,%dM,&ir&j,&w) ; /* 输入边(vi,vj )上的权 w */ G->arc[i][j]=w;
            G->arc[j] [i]= G->arc(i] [j]; /* 因为是无向图，矩阵对称 */
        }
    }
    // 从代码中也可以得到，n个顶点和e条边的无向网图的创建，时间复杂度为 0(n+n2+e),其中对邻接矩阵的初始化耗费了O(n^2)的时间。
    ```

* **邻接表**

  * 邻接矩阵是不错的一种图存储结构，但是，对于边数相对顶点较少的图，这种结构是存在对存储空间的极大浪费的。在线性表时谈到，顺序存储结构 就存在预先分配内存可能造成存储空间浪费的问题，于是引出了链式存储的结构。同 样的，我们也可以考虑对边或弧使用链式存储的方式来避免空间浪费的问题。

  * 数组与链表相结合的存储方法称为邻接表 (Adjacency List)

    *  图中顶点用一个一维数组存储，当然，顶点也可以用单链表来存储，不过数组 可以较容易地读取顶点信息，更加方便。另外，对于顶点数组中，每个数据元 素还需要存储指向第一个邻接点的指针，以便于查找该顶点的边信息。
    *  图中每个顶点 vi 的所有邻接点构成一个线性表，由于邻接点的个数不定，所以 用单链表存储，无向图称为顶点 vi 的**边表**，有向图则称为顶点 vi 作为弧尾的**出边表**（可以较快获取顶点的出度）。
      * 有时为了便于确定顶点的入度或以顶点为弧头的弧，我们可以建立一个有向图的逆邻接表，即对每个顶点VI都建立一个链接为 vi为弧头的表。 
    * 对于带权值的网图，可以在边表结点定义中再增加一个weight的数据域，存储权值信息即可.

    ```
    typedef char VertexType;  /*顶点类型应由用户定义*/
    typedef int EdgeType;   /*边上的权值类型应由用户定义*/
    
    typedef struct EdgeNode /*边表结点*/
    {
        int adjvex; 	 /*邻接点域，存储该顶点对应的下标 */
        EdgeType weight; 	 /*用于存储权值，时于非网图可以不需要*/
        struct EdgeNode *next;  /*链域，指向下一个邻接点*/
    } EdgeNode;
     
    typedef struct VertexNode /*顶点表结点*/
    {
        VertexType data;		/* 顶点域，存储顶点信息 */
        EdgeNode *firstedge;	/*边表头指针*/
    } VertexNode, AdjList[MAXVEX];
    
    typedef struct
    {
        AdjList adjList;
        int numvertexes, numEdges; /*图中当前顶点数和边数*/
    } GraphAdjList;
    ```

    ```
    // 对于邻接表的创建，也就是顺理成章之事。无向图的邻接表创建代码如下。
    /*建立图的邻接表结构*/
    void CreateALGraph ( GraphAdjList *G )
    {
        int i, j, k;
        EdgeNode *e;
        printf ( ”输入顶点数和边数；\n” );
    	scanf ( "%d, %d", &G->numVertexes, &G->numEdges ) ;/* 输入顶点数和边数 */ 
    	for ( i = 0; i < G->numVertexes; i++ )	/* 读入顶点信息，建立顶点表 */
    	{
    		scanf ( &G->adjList[i].data );
    		G->adjList[i].firstedge=NULL;
        }
    	for ( k = 0;k < G->numEdges;k++ )	/* 建立边表 */
    	{	
    		Printf (“输入边(vi,vj)上的顶点序号:\n");
    		scanf("%d, %d", &i, &j) ； /* 输入边(vi,vj)上的顶点序号 */
            e= ( EdgeNode * ) malloc ( sizeof ( EdgeNode ) ) ; /*向内存申请空间*/
            /*生成边表结点*/ 
            e->adjvex=j;	/* 邻拱序号为 j */
            e->next=G->adjList[i].firstedge;/*将e指卄指向当前頂点指向的始点*/ 
            G->adjList[i].firstedge=e; /* 将当前顶点的指针指向 e */
            e= (EdgeNode * ) malloc (sizeof (EdgeNode) ) ; /*向内存申请空间*/
            /* 生成边表給点 */ 
            e->adjvex=i ;	/* 邻接序号为 i */
            e->next=G->adjList[j].firstedge;/*将e针指向当前顶点指向的结点*/
            G->adjLiat[j].firstedge = e; /* 将当前顶点的指针指向e*/
        }
    }
    // 邻接顶点运用头插法插入邻接表中
    // 算法复杂度为 O(n+e)
    ```

* **十字链表**

  * 对于有向图来说，邻接表是有缺陷的。关心了出度问题，想了解入度就必须 要遍历整个图才能知道，反之，逆邻接表解决了入度却不了解出度的情况。有没有可 能把邻接表与逆邻接表结合起来呢？答案是肯定的，就是把它们整合在一起。

  * 十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样既容易找到以 VI为尾的弧，也容易找到以V为头的弧，因而容易求得顶点的出度和入度。而且它除 了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的

    ```
    /*其中tailvex是指弧起点在顶点表的下标，headvex是指弧终点在顶点表中的下标，headlink是指入边表指针域，指向终点相同的下一条边; taillink是指边表指针域，指向起点相同的下一条边。如果是网，还可以再增加一个weight域来存储权值。*/
    
    typedef char VertexType;  /*顶点类型应由用户定义*/
    typedef int EdgeType;   /*边上的权值类型应由用户定义*/
    
    typedef struct EdgeNode /*边表结点*/
    {
        int tailvex; 	 /*弧尾*/
        int headlvex; 	 /*弧头*/
    	EdgeNode *tailLink, *headLink;  /*下一条出边链接*/  /*下一条入边链接*/
    } EdgeNode;
     
    typedef struct VertexNode /*顶点表结点*/
    {
        VertexType data;		/* 顶点域，存储顶点信息 */
        EdgeNode *firstin, *firstOut;
    } VertexNode, AdjList[MAXVEX];
    
    typedef struct
    {
        AdjList adjList;
        int numvertexes, numEdges; /*图中当前顶点数和边数*/
    } GraphAdjList;
    ```

* **邻接多重表**

  * 如果我们在无向图的应用中，关注的重点是顶点，那么邻接表是不错的选择，但如果我们更关注 边的操作，比如对已访问过的边做标记，删除某一条边等操作，那就意味着，需要找到这条边的两个边表结点进行操作，这其实还是比较麻烦的。

    ```
    /*其中 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中下标。ilink 指向依附顶点ivex的下一条边，jlink指向依附顶点jvex的下一条边。这就是邻接多重表结构。*/
    typedef struct EdgeNode /*边表结点*/
    {
        int ivex; 
        int jvex; 
        EdgeNode *ilink, *jlink;
    } EdgeNode;
    /* ilink 指向的结点的 jvex 一定要和它本身的ivex的值相同*/
    ```

* **边集数组**

  * 边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信 息,这个边数组每个数据元素由一条边的起点下标(gebin)、终点下标(end)和权 (weigtht)组成

  * 边集数组关注的是边的集合，在边集数组中 要查找一个顶点的度需要扫描整个边数组，效率并不高。因此它更适合对边依次进行 处理的操作，而不适合对顶点相关的操作。

    ```
    
    ```

---

##### 图的遍历

* 图的遍历是和树的遍历类似，我们希望从图中某一顶点出发访遍图中其余顶点， 且使每一个顶点仅被访问一次，这一过程就叫做图的遍历(TraversingGraph)。

* 树的遍历我们谈到了四种方案，应该说都还好，毕竟根结点只有一个，遍历都是 从它发起，其余所有结点都只有一个双亲。可图就复杂多了，因为它的任一顶点都可 能和其余的所有顶点相邻接，极有可能存在沿着某条路径搜索后，又回到原顶点，而 有些顶点却还没有遍历到的情况。因此我们需要在遍历过程中把访问过的顶点打上标记，以避免访问多次而不自知。具体办法是设置一个访问数组visited[n], n是图中顶点的个数，初值为0,访问过后设置为1.

* **图的深度优先遍历类似树的前序遍历，那么图的广度优先遍历就类似于树 的层序遍历了。**

* **深度优先遍历**(Depth_First_Search),也有称为深度优先搜索，简称为DFS。

  * 它从图中某个顶点v出发，访问此顶点，然后从v的未被访问的邻接点出发 深度优先遍历图，直至图中所有和v有路径相通的顶点都被访问到。事实上，我们 这里讲到的是连通图，对于非连通图，只需要对它的连通分量分别进行深度优先遍 历，即在先前一个顶点进行一次深度优先遍历后，若图中尚有顶点未被访问，则另 选图中一个未曾被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问 到为止。

  ```
  // 如果我们用的是邻接矩阵的方式，则代码如下：
  typedef int Boolean;	/* Boolean 是布尔类型，其值是 TRUE 或 FALSE */
  Boolean visited[MAX];	/* 访问标志的数组 */
  
  /*邻接矩阵的深度遍历操作*/
  void DFSTraverse ( MGraph G )
  {
      int i;
      for (i = 0; i < G.numVertexes; i++)
          visited[i] = FALSE; /*初始所有顶点状态都是来访问过状■态*/
      for ( i = 0; i < G.numVertexes; i++)
          if ( !visited[i] ) /*对未访问过的顶点调用DFS,若是连通图，只会执行一次*/ 
          	DFS ( G, i)；
  }
  
  /*邻接矩阵的深度优先递归算法*/
  void DFS (MGraph G, int i )
  {
      int j;
      visited[i] = TRUE;
      printf ( "%c ”，G.vexs[i] ) ;	/*打印项点，也可以其他操作*/
      for (j = 0; j < G.numVertexes; j++)
          if(G.arc[i] [j] == 1 && !visited[j])
              DFS ( G, j ) ;	/*对为访问的邻接顶点递归週用*/
  }
  ```

  ```
  /*如果图结构是邻接表结构，其DFSTraverse函数的代码是几乎相同的，只是在递 归函数中因为将数组换成了链表而有不同，代码如下。*/
  
  /*邻接表的深度遍历操作*/
  void DFSTraverse (GraphAdjList GL)
  {
      int i;
      for ( i = 0; i < GL->numVertexes; i++)
          visited[i] = FALSE; /*初始所有顶点液态都是未访问过状态•/
      for ( i = 0; i < GL->numVertexes; i++)
          if ( !visited(i] ) /*对未访问过的顶点调用DFS,若是连通图，只会执行一次*/ 
          	DFS (GL, i );
  }
  
  /*邻接表的深度优先递归算法*/
  void DFS (GraphAdjList GL, int i)
  {
      EdgeNode *p;
      visited[i] = TRUE;
      printf ( "%c", GL->adjList[i].data) ; /* 打印顶点，也可以其他操作 */
      P = ,->adjList[i].firstedge;
      while (p)
      {
          if (!visited[p->adjvex])
              DFS(GL, p->adjvex) ; /*对为访问的邻接頂点递贬调用*/
          p = p->next;
      }
  }
  
  ```

  * 对比两个不同存储结构的深度优先遍历算法，对于n个顶点e条边的图来说，邻 接矩阵由于是二维数组，要查找每个顶点的邻接点需要访问矩阵中的所有元素，因此 都需要0(n^2)的时间。而邻接表做存储结构时，找邻接点所需的时间取决于顶点和边 的数量，所以是0(n + e)。显然对于点多边少的稀疏图来说，邻接表结构使得算法在时 间效率上大大提高。
  * 对于有向图而言，由于它只是对通道存在可行或不可行，算法上没有变化，是完 全可以通用的
    * 需要访问所有的边已确定是否完成所有访问

* **广度优先遍历**(Breadth.FirscSearch),又称为广度优先搜索，简称BFS

  ```
  /*邻接矩阵的广度遍历算法*/
  void BFSTraverse ( MGraph. G )
  {
      int i, j；
      Queue Q;
      for (i = 0; i < G.numVertexes; i++)
          visited[i] = FALSE;
      InitQueue ( &Q) ;	/*初始化一辅助用的队列*/
      
      for ( i = 0; i < G.numvertexes; i++ )	/* 对每一个顶点做循环 */
      {
      if ( !visited[i] )	'	/*若是未访问过就处理•/
      {
          visited[i]=TRUE;	/*设置当前顶点访问过*/
          printf ( "%c", G.vexs[i] ) ;/*打印顶点，也可以其他操作*/ 		 EnQueue ( &Q, i ) ;	/*将此顶点入队列*/
          while ( IQueueEmpty(Q)) /* 若当前队列不为空 */
          {
          	DeQueue(&Q, i)	;	/*将队中元素出队列，賊值给i */
              for (j=O;j<G.numVertexes;j++ )
              {
              /*判断其他顶点若与当前顶点存在边且未访问过*/ 
              if (G.arc[i][j] == 1 && !visited[j])
              {
                  visited[j]=TRUE; /*将找到的此顶点标记为巳访问*
                  / printf ("%c"，G.vexs(j] ) ; /* 打印顶点 */ 
                  EnQueue (&Q,j) ;	/*将找到的此顶点入队列*/
              }
      }
  }
  ```

  ```
  /*对于邻接表的广度优先遍历，代码与邻接矩阵差异不大，代码如下。*/
  /*邻接表的广度過历算法•/
  void BFSTraverse (GraphAdjList GL)
  {
      int i;
      EdgeNode *p;
      Queue Q;
      for ( i = 0; i < GL->numVertexes; i++ )
          visited[i] = FALSE;
      InitQueue ( &Q);
      for ( i = 0; i < GL->numVertexes; i++)
      {
          if (!visited[i])
          {
              visited[i]=TRUE;
              printf ( "%c" , GL->adjList(i] .data) ;/* 打印顶点，也可以其他捷作 */ 
              EnQueue ( &Q, i);
              while ( JQueueEmpty ( Q ))
            	{
                  DeQueue ( &Q, &i);
                  P = GL->adjList[i].firstedge;	/*到当前顶点边表链表头指针*/
                  while (p)
                  {
                      if( !visited[p->adjvex) )	/* 若此顶点未被访间*/
                      {
                          visited[p->adjvex]=TRUE;
                          printf ( "%c M,GL->adjList(p->adjvex].data); 
                          EnQueue ( &Q,p->adjvex ) ; /* 将此顶点入队列 */
                  	}
              		P = p->next;	/*指针指向下一个邹接点*/
                  }
              }
          }
      }
  }
  ```
* 对比图的深度优先遍历与广度优先遍历算法，你会发现，它们在时间复杂度上是 一样的，不同之处仅仅在于对顶点访问的顺序不同。可见两者在全图遍历上是没有优劣之分的，只是视不同的情况选择不同的算法。不过如果图顶点和边非常多，不能在短时间内遍历完成，遍历的目的是为了寻找合适的顶点，那么选择哪种遍历就要仔细斟酌了。深度优先更适合目标比较明确，以找到目标为主要目的的情况，而广度优先更适合在不断扩大遍历范围时找到相对最优解的情况。

* 这里还要再多说几句，对于深度和广度而言，已经不是简单的算法实现问题，完 全可以上升到方法论的角度。你求学是博览群书、不求甚解，.还是深钻细研、鞭辟入里；你旅游是走马观花、蜻蜓点水，还是下马看花、深度体验；你交友是四海之内皆 兄弟，还是人生得一知己足矣……其实都无对错之分，只视不同人的理解而有了不同 的诠释。我个人觉得深度和广度是既矛盾又统一的两个方面，偏颇都不可取，还望大 家自己慢慢体会。

---

##### 最小生成树

* 一个连通图的生成树是一个极小的连 通子图，它含有图中全部的顶点，但只有足以构成一棵树的 n-1条边。

* 构造连通网的最小代价生成树称为最小生成树

* 普里姆算法

  ```
  /* 邻接矩阵 */
  /* Prim算法生成最小生成树 */
  void MiniSpanTree_Prim ( MGraph G )
  {
      int min, i, j, k;
      int adjvex [MAXVEX]; /*保存相关顶点下标*/
      int lowcost [MAXVEX] ; /*保存相关顶点间边的权值*/
      lowcost [0] = 0;	/*初始化第一个权值为0,即V0加入生成树*/
      /* lowcost的值为0,在这里就是此下标的顶点巳经加入生成树*/
      adjvex[0] = 0;	/*初始化第一个顶点下标为0 */
      
       /*循环除下标为v0外的全部顶点*/
      for ( i = 1; i < G.numVertexes; i++)
      {
          lowcost[i] = G.arc [0][i];/*将Vo顶点与之有边的权值存入数组"
          adjvex [i] = 0;	/*初始化都为v0的下标*/
      }
      
      /* 执行 n - 1 次循环， 每次将一个暂未加入生成树的节点加入树中 */
      for ( i = 1; i < G.numVertexes; i++ )
      {
          min = INFINITY; /*初始化最小权值为无穷大 */         /*通常设置为不可能的大数字如32767、65535等*/
  
  		/* 寻找当前最小权值且暂未加入生成树的节点 */
          j = l；k = 0;
          while ( j < G.numvertexes )	/* 搦环全部顶点 */
          {
          	/*如果权值不为0且权值小于min */
              if (lowcost[j]!=0 && lowcost[j] < min )
              {
                  min = lowcost[j];	/*则让当前权值成为最小值*/
                  k = j;	/*将当前最小值的下标存入k */
              }
              j++；
          }
          
          printf ("(%d, %d)", adjvex[k], k );/*打印当前顶点边中权值最小边*/ 
          lowcost[k] = 0; /*将当前顶点的权值设置为0,表示此顶点已经完成任务*/  
          /* 加入新顶点后，更新节点的最小权值 */
          for ( j = 1; j < G.numvertexes; j++ )	/* 循环所有顶点 */
          {
              /*若下标为k顶点各边权值小于此药这些顶点未被加入生成树权值*/
              if (lowcost[j]!=0 && G.arc[k][j] < lowcost[j])
          	{ 
          		lowcost [j] = G.arc[k][j ];/* 将较小权值存入 lowcost*/ 
          		adjvexf[j] = k;	/*将下标为k的顶点存入adjvex */
              }
          }
      }
  }
  ```

  * 假设  $N = (P, E)$ 是连通网，TE 是 N上 最小生成树中边的集合。算法从$U = {u_0} (u_0 \in V), TE = \{\}$开始。重复执行下述操作：在所有$u \in U, v \in{V-U}的边(u,v) \in E$中 找一条代价最小的边$(u_0, v_0)$并入集合 TE ,同时 v0 并入U,直至 U=V 为止。此时 TE 中必有 n-1 条边，则 $T = （V, {TE}）$ 为N的最小生成树。由算法代码中的循环嵌套可得知此算法的时间复杂度为 O(n^2)

* **克鲁斯卡尔算法**

  * 可以直接就以边为目标去构建，因为权值是在边上，直接去找最小权值的边来构建生成树也是很自然的想法，只不过构建时要考虑是否会形成环路而已。 此时我们就用到了图的存储结构中的边集数组结构。

  * edge边集数组结构的定义代码：

    ```
    /* 对边集数组 Edge 结构的定义*/
    typedef struct
    {
        int begin;
        int end;
        int weight;
    } Edge;
    ```

  * 将图的邻接矩阵通过程序转化为图的边集数组，并且对它们按权值从小到大排序。

  ```
  /* Kruskal算法生成最小生成树*/
  void MiniSpanTree_Kruskal (MGraph G ) /* 生成最小生成树 */
  {
      int i, n, m;
      Edge edges [MAXEDGE] ; /* 定义边集数组 */
      int parent [MAXVEX]; /*定义一数组用来判断边与边是否形成环路*/
      
    /* 此处省略邻接矩阵 G 转化为边集数组 edges 并按权由小到大排序的代码*/ 
    
    	/*初始化数组值为0 */
      for (i = 0; i < G.numVertexes; i++)
          parent [i] = 0;
          
      /*循环每一条边，将权值最小且不会与已有生成树形成环路的边加入树中*/
      for (i = 0; i < G.numEdges; i++)
      {
          n = Find (parent.edges[i].begin );
          m = Find ( parent.edges [i].end);
          /* 假如n与m不等，说明此边没有与现有生成树形成环路 */
          if (n != m)  
          {
          	/* 将此边的结尾顶点放入下标为起点的parent中 */
          	parent[n] = m;
              /*表示此顶点已经在生成树集合中*/
              printf ( " ( %dr %d) %d ", edges[i].begin,
              edges[i].end, edges[i].weight);
          }
  }
  
  /* 査找连线顶点的尾部下标 */
  int Find (int *parent, int f ) 
  {
      while (parent[f] > 0 )
          f = parent[f];
      return f;
  }
  ```

  * 假设 N= (V,{E}) 是连通网，则令最小生成树的初始状态为只有 n 个顶点而无边的非连通图T=(V, {} },图中每个顶点自成一个连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在T中不同的连通分量上，则将此边加入到 T中，否则舍去此边而选择下一条代价最小的边。依次类推，直至T中所有顶点都在同一连通分量上为止。此算法的 Find 函数由边数 e 决定，时间复杂度为O(loge),而外面有一个for循环 e次。所以克鲁斯卡尔算法的时间复杂度为O(eloge)。

* 对比两个算法，克魯斯卡尔算法主要是针对边来展开，边数少时效率会非常高， 所以对于稀疏图有很大的优势；而普里姆算法对于稠密图，即边数非常多的情况会更 好一些。

---

##### 最短路径

* 在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值， 所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而对于网图来说， 最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第 一个顶点是源点，最后一个顶点是终点。
* **单源最短路径问题**   从某个源点到其余各顶点的最短路径问题

* **迪杰斯特拉(Dijkstra )算法**

  * 这是一个按路径长度递增的次序产生最短路径的算法。
  * 它并不是一下子就求出了源点到终点的最短路径，而是一步步求出它们之间顶点的最短路径，过程中都是基于已经求出的最短路径的基础上，求得更远顶点的最短路径，最终得到你要的结果(贪婪算法)。

  ```
  /* D代表顶点到顶点的最短路径权值和 的矩阵。P代表对应顶点的最小路径的前驱矩阵。 */
  #define MAXVEX 9
  #define INFINITY 65535
  typedef int Pathmatirx[MAXVEX];	/*用于存储最短路径下标的数组*/
  typedef int ShortPathTable[MAXVEX]; /*用于存储到各点最短路径的权值和*/ 
  
  /* Dijkstra算法，求有向网 G 的 V0 顶点到其余顶点 v 最短路径 P[v] 及带权长度D[v] */
  /* P[V]的值为前驱顶点下标，D[V]表示 V0 到 V 的最短路径长度和 */
  
  void ShortestPath_Dijkstra(MGraph G, int v0, Pathmatirx *P,
  ShortPathTable *D)
  {
  	int v, w, k, min;
  	int final[MAXVEX]; /* final[w] = 1表示当前节点w已求得到源点v0的最短路径（后续不需要在参与最短路径的求值）*/
  	
      /*执行初始化*/
      for (v=0; v<G.numVertexes; v++)
      {
      	final[v] = 0;	/*所有顶点均为求的到源点的最短路径*/
      	(*D)[v] = G.matrix[v0][v]; /*顶点到源点的`当前最短路径`*/
      	(*p)[v] = 0; /*所有节点暂时都不存在最短路径的前驱节点*/
  	}
      (*D)[v0] = 0; 	/*源点自身的最短路径设置为0*/ 
      final[v0] = 1;	/*源点自身已找到最短路径*/ 
      
      /*开始主循环，每次求得V0到某个v顶点的最短路径*/ 
      for (v=l; v<G.numVertexes; v++)
          min=INFINITY;	/*当前所知距离v0顶点最近的距离*/
          /* 寻找离 v0 顶点最近的距离*/
          for ( w=0; w<G.numVertexes; w++)
          {
              if ( ! final [w] && (*D)[w]<min)
              {
                  k=w;
              	min = (*D)[w];	/* w顶点髙v0顶点更近*/
              }
          }
          /*将当前距离源点路径最短的节点标识为已求得最短路径的节点*/
          final [k] = 1;	
          
          /* 修正当前最短路径及距离*/
          for ( w=0; w < G.nximVertexes; w++ ) 
          {
          /*如果经过v顶点的路径比现在这条路径的长度短的话. 说明找到了更短的路径，修改D[w]和P[w]*/
          if ( !final [w] && (min+G.matirx[k][w]< (*D)[w]))
          {
          	(*D) [w] = min + G.matirx[k][w];/*修改当前路径长度*/ 			 (*P)[w] = k; /*修改使前节点到达源节点最短路径的前驱节点*/
        	}
      }
  }
  /* 当前节点 i 的最短路径等于 (*D)[i] 和第 i-1 个节点加入之后,  (*D)[i-1] + G.matrix[i-1][i]  */
  /*  最终返回的数组D和数组P,是可以得到 V0 到任意一个顶点的最短路径和路径长度的。 */
  ```

  * 通过迪杰斯特拉（Dijkstra）算法解决了从某个源点到其余各顶点 的最短路径问题。从循环嵌套可以很容易得到此算法的时间复杂度为0（n^2）,尽管有 同学觉得，可不可以只找到从源点到某一个特定终点的最短路径，其实这个问题和求源点到其他所有顶点的最短路径一样复杂，时间复杂度依然是0（n^2）。
  * 任一顶点到其余所有顶点的最 短路径时简单的办法就是对每个顶点当作源点运行一次迪杰斯特拉 （Dijkstra）算法，等于在原有算法的基础上，再来一次循环，此时整个算法的时间复 杂度就成了 0（n^3）。

* 弗洛伊德（Floyd ）算法

  ```
  typedef int Pathmatirx[MAXVEX][MAXVEX];
  typedef int ShortPathTable[MAXVEX)[MAXVEX];
  
  /* Floyd算法，求网图 G 中各顶点v到其余顶点w最端路径 P[v][w] 及帯权长度D[v][w] */
  
  void ShortestPath_Floyd (MGraph G, Pathmatirx *P, ShortPathTable *D)
  {
      int v,w,k;
      /* 初始化 D 与 P */
  	for ( v=0; v<G.numVertexes; ++v)	
      {
      	for (w=0; w<G.numVertexes; ++w )
      	{
      		/* D[v][w]为对应点间的权值 */
      		(*D)[v][w] = G.matirx[v] [w];	
      		(*P)[v][w] = w;	
      	}
     	}
  
      for	(k=0; k<G.numVertexes;	++k)
      {
          for (v=0; v<G.numVertexes; ++v)
          {
              for (w=0; w<G.numVertexes; ++w)
              {
                  /*如果经过下标为k顶点路径比原两点间维径更短*/
                  /*将当前两点间权值设为更小的一个*/
                  /*更新节点当前最短路径的直接前驱元素*/
                  if ((*D)[v][w] > (*D)[v][k]+ (*D)[k][w])、					{
                      (*D)[v][w] = (*D)[v][k] + (*D)[k][w];
                      (*P)(V] [w] = (*P)[v][k];
                  }
              }
          }
  	}
  }
  ```

  * 依据 P 最短路径数组求出最短路径信息

    ```
    for(v = 0; v < G.numVertexes; ++v)
    {
    	for(w = 0; w < G.numVertexes; ++w)
    	{
    		printf ( "v%d-v%d weight: %d",  v, w, D[v][w]);
    		k = P[v][w];
    		printf (" path: %d",v); 
    		while ( k!=w )
            {
            	printf ("->%d ", k);
                k=P[k][w];
            }
            printf ( "-> %d\nw, w );
    	}
        printf ( "\n");
    }
    ```

---

##### 拓扑排序

* **无环的图**   无环，即是图中没有回路的意思。
* 在一个表示工程的有向图中，用顶点表示活动，用孤表示活动之间的优先关系， 这样的有向图为顶点表示活动的网，我们称为AOV网(Activity On Vertex Network )。
  * AOV网中的弧表示活动之间存在的某种制约关系。
  * AOV网中不能存在回路。
* 设 G=(V,E) 是一个具有n个顶点的有向图，V中的顶点序列Vi1 V2,……,Vn, 满足若从顶点 vi 到 vj 有一条路径，则在顶点序列中顶点 vi 必在顶点 vj之前。则我们称这样的顶点序列为一个**拓扑序列**。
* 所谓拓扑排序，其实就是对一个有向图构造拓扑序列的过程。
  * 构造时会有两个结果，如果此网的全部顶点都被输出，则说明它是不存在环（回路）的AOV网；如果输 出顶点数少了，哪怕是少了一个，也说明这个网存在环（回路），不是AOV网。

* 一个不存在回路的AOV网，我们可以将它应用在各种各样的工程或项目的流程图 中，满足各种应用场景的需要，所以实现拓扑排序的算法就很有价值了。

* 拓扑排序算法

  * 对AOV网进行拓扑排序的基本思路是：从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤，直到输出全部顶点或者AOV网中不存在入度为 0 的顶点为止。

  * 先我们需要确定一下这个图需要使用的数据结构。前面求最小生成树和最短路 径时，我们用的都是邻接矩阵，但由于拓扑排序的过程中，需要删除顶点，显然用邻 接表会更加方便。因此我们需要为AOV网建立一个邻接表。考虑到算法过程中始终要 查找入度为0的顶点，我们在原来顶点表结点结构中，增加一个入度域 in

    ```
    /*边表结点*/
    typedef struct EdgeNode
    {
        int adjvex;		/*邻接点域，存储该頂点对应的下标*/
        int weight;		/*用于存緒权值，对于非网图可以不需要*/
        stxruct EdgeNode *next;	/*指向下一个邻接点•/
    } EdgeNode;
    
    /* 頂点表结点 */
    typedef struct VertexNode
    {
        int in;	/*顶点入度*/
        int data;	/*数据域，存储顶点信息*/
        EdgeNode *firstedge;	/*边表头指針*/
    } VertexNode, AdjList[MAXVEX];
    
    /* 图 */
    typedef struct
    {
        AdjList adjList;
        int numVertexes,numEdges; /*图中当前頂点数和边数*/
    } graphAdjList,*GraphAdjList;
    ```

  * 在算法中，我还需要辅助的数据结构一栈，用来存储处理过程中入度为 0 的顶点，目的是为了避免每个查找时都要去遍历顶点表找有没有入度为 0 的顶点。

  ```
  拓扑排序，若GL无回路，则输出拓扑排序序列并返回OK,若有回路返回ERROR */
  Status TopologicalSort (GraphAdjList GL)
  {
      EdgeNode *e;
      int i,k,gettop;
      int top = 0; /*用于栈指针下标*/
      int count = 0; /*用于统计输出顶点的个數*/
      int *stack;  /*建栈存储入度为0的顶点*/
      stack = (int *) malloc(GL->numVertexes * sizeof ( int))；
      
      /*init*/
      /*将入度为。的顶点入栈*/
      for ( i = 0; i<GL->numVertexes; i++)
      	if(GL->adjList(i].in = 0)
      		stack[++top] =i;	
      		
      		
      while (top!=0)
      {
          gettop=stack[top--]; /* 出栈 •/
          printf ( "%d -> ", GL->adjList[gettop].data) ; /* 打印此顶点 */ 
          count++; /*统计输出顶点数*/
          
          /*对此顶点弧表遍历*/
          for ( e=GL->adjList[gettop].firstedge; e; e=e->next)
          {
              k = e->adjvex;
              /*将k号顶点邻接点的入度滅1*/ 
              if (!(—GL->adjList[k].in) ) 
              	/*若为 0 則入栈，以便于下次鶴环输出*/
              	stack[++top]=k; 
          }
      }
   
      if ( count < GL->numVertexes ) /*如果count小于顶点数，说明存在环*/
      	return ERROR;
      else
      	return OK;
  }
  ```

  * 分析整个算法，对一个具有n个顶点e条弧的AOV网来说，将入度为0的顶点入栈的时间复杂为0(n），而之后的while循环中，每个顶点 进一次栈，出一次栈，入度减1的操作共执行了 e 次，所以整个算法的时间复杂度为 0(n+e)

---

##### 关键路径

* 拓扑排序主要是为解决一个工程能否顺序进行的问题，但有时我们还需要解决工 程完成需要的最短时间问题。
* 关键路径通常是所有工程活动中最长的路径，关键路径上的活动如果延期将直接导致工程延期。
* 我们如果要对一个流程图获得最短时间，就必须要分析它们的拓扑关系， 并且找到当中最关键的流程，这个流程的时间就是最短时间。
* 利用 AOV 网表示有向图，可以对活动进行拓扑排序，根据排序结果对工程中活动的先后顺序做出安排。但是寻找关键路径，估算工程活动的结束时间，则需要使用 AOE 网表示有向图。
* 一个表示工程的 带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续 时间，这种有向图的边表示活动的网，我们称之为AOE网(Activity On Edge Network)。
  * AOE网中没有入边的顶点称为始点或源点
  * 没有出边的顶点称为 终点或汇点
  * 由于一个工程，总有一个开始，一个结束，所以正常情况下，AOE网只 有一个源点一个汇点。
  * 既然AOE网是表示工程流程的，所以它就具有明显的工程的特性。如有在某顶点 所代表的事件发生后，从该顶点出发的各活动才能开始。只有在进入某顶点的各活动 都已经结束，该顶点所代表的事件才能发生。
  * 尽管AOE网与AOV网都是用来对工程建模的，但它们还是有很大的不同，主要 体现在AOV网是顶点表示活动的网，它只描述活动之间的制约关系，而AOE网是用边表示活动的网，边上的权值表示活动持续的时间
  * AOE网是要建立在活动之间制约关系没有矛盾的基础之上，再来分析完成整个工程至少需要多少时间，或者为缩短完成工程所需时间，应当加快哪些活动等问题。

![image-20200425122607418](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20200425122607418.png)

* 把路径上各个活动所持续的时间之和称为路径长度，从源点到汇点具有最大 长度的路径叫关键路径，在关键路径上的活动叫关键活动。

* 活动的最早开始时间和最晚开始时间。

  * 工程中一个活动何时开始依赖于其前驱活动何时结束，只有所有的前驱活动都结束后这个活动才可以开始，**前驱活动都结束的时间就是这个活动的最早开始时间**。与此同时，在不影响工程完工时间的前提下，有些活动的开始时间存在一些余量，在**时间余量**允许的范围之内推迟一段时间开始活动也不会影响工程的最终完成时间，活动的最早开始时间加上这个时间余量就是活动的**最晚开始时间**。活动不能在最早开始时间之前开始，当然，也不能在最晚开始时间之后开始，否则会导致工期延误。**如果一个活动的时间余量为 0，即该活动的最早开始时间和最晚开始时间相同，则这个活动就是关键活动**，由这些关键活动串起来的一个工程活动路径就是关键路径。根据关键路径的定义，一个工程中的关键路径可能不止一个，我们常说的**关键路径指的是工程时间最长的那条路径，也就是从源点到汇点之间最长的那条活动路径。**

* **关键路径算法原理**   只需要找到所有活动的最早开始时间和最晚开始时间，并且比较 它们，如果相等就意味着此活动是关键活动，活动间的路径为关键路径。如果不等， 则就不是。

  * 事件的最早发生时间 etv  (earliest time of vertex): 即顶点 Vk 的最早发生时 间。
  *  事件的最晚发生时间 Itv  (latest time of vertex): 即顶点 Vk 的最晚发生时间， 也就是每个顶点对应的事件最晚需要开始的时间，超出此时间将会延误整个工 期。
  *  活动的最早开工时间 ete  (earliest time of edge): 即弧 ak 的最早发生时间。
  *  活动的最晚开工时间 Ite  (latest time of edge): 即弧 ak 的最晚发生时间，也就是不推迟工期的最晚开工时间。

* 数据结构定义

  ```
  /*边表结点*/
  typedef struct EdgeNode
  {
      int adjvex;		/*邻接点域，存储该頂点对应的下标*/
      int weight;		/*用于存緒权值，对于非网图可以不需要*/
      stxruct EdgeNode *next;	/*指向下一个邻接点 */
  } EdgeNode;
  
  /* 頂点表结点 */
  typedef struct VertexNode
  {
      int in;	/*顶点入度*/
      int data;	/*数据域，存储顶点信息*/
      EdgeNode *firstedge;	/*边表头指針*/
  } VertexNode, AdjList[MAXVEX];
  
  /* 图 */
  typedef struct
  {
      AdjList adjList;
      int numVertexes,numEdges; /*图中当前頂点数和边数*/
  } graphAdjList,*GraphAdjList;
  ```

* 拓扑排序算法

  ```
  /*全局变量*/
  int *etv,*ltv;  /*事件最平发生时间和最迟发生时间数组*/
  int *stack2;    /*用于存储拓扑序列的栈*/
  int top2;	    /* 用于 stack2 的指针 */
  
  /*拓扑排序，用于关键路径计算*/
  Status TopologicalSort ( GraphAdjList GL)
  {
      EdgeNode *e;
      int	i,k,gettop;
      int	top = 0;	/*用于栈指针下标*/
      int	count = 0;	/*用于统计输出顶点的个數*/
      int *stack;	
      stack= (int*) malloc (GL->numVertexes * sizeof ( int));
      /*建栈将入度为0的顶点入栈*/
      for ( i = 0; i<GL->numVertexes; i++ )
          if(0 == GL->adjList[i].in)
              stack[++top] = i;
  
      top2=0;	/*初始化为 0 */
      /* 事件最早发生时间 */
      etv = (int *)malloc (GL->numVertexes*sizeof (int)); 
      for (i=0; i < GL->numVertexes; i++ )
      	etv[i]=0;	/* 初始化为 0 */
  
      stack2 = (int *)malloc(GL->numVertexs*sizeof(int));
      
      /* 开始执行 */ 
      while (top != 0)
      {
      	/*不存在入度的顶点*/
          gettop=stack[top--];
          count++;
          stack2 [++top2] = gettop; /*将弹出的頂点序号压入拓扑序列的栈*/
          for (e =GL->adjList[gettop].firstedge; e; e = e->next)
          {
              k = e->adjvex;
            /*当前节点在gettop依赖完成之后若不存在依赖则可以等待执行了*/
              if (!(--GL->adjList[k].in))
              	stack[++top]=k;
              	
              /*求各顶点事件的最早发生时间*/
              /*顶点的最早须要在个依赖顶点执行完成后才可发生*/
              if ((etv[gettop] + e->freight) > etv[k])	
              	etv[k] = etv [gettop] + e->weight;
          }
      }
      if (count < GL->numVertexes)
      	return	ERROR;
      else
      	return	OK;
  }
  ```

  * 对顶点 vk 求 etv[k] 的最早发生时间的公式是：（其中 P[K] 表示所有到达顶点 Vk 的弧的集合）
    $$
    etv[k] = \begin{cases}
    0, & k =0 \\
    max \{ etv[i] + len<v_i, v_k> \}, & 当 k \neq 0 且 <v_i, v_k> \in P[k]时
    \end{cases}
    $$

  * 求关键路径的算法代码

    ```
    /*求关键路径，GL为有向网，输出GL的各项关键活动*/
    void CriticalPath ( GraphAdjList GL )
    {
        EdgeNode *e;
        int i,gettop,k,j;
        int ete,lte;	/*声明活动最早发生时间和最迟发生时间变量*/
        TopologicalSort(GL) ;	/* 求拓扑序列，计算数组 etv 和stack2的值 */
        /* 初始化事件最晚发生时间*/
        ltv = (int *) malloc (GL->numVertexes*sizeof (int));
        for (i=0; i < GL->numVertexes; i++)
        	ltv[i] =etv[GL->numVertexes-l] ; /* 初始化 Itv */
        
        /* 计算 Itv */
        while (top2 != 0)	
        {
        	/*将拓扑序列出栈，后进先出 (从最后一个完成的事件开始执行)*/
            gettop=stack2[top2--];
            /* 查看当前事件的依赖事件 */
            for(e=GL->adjList[gettop].firstedge; e;e=e>next)
            {
            	/*求各顶点事件的最迟发生时间Itv值*/
                k=e->adjvex;
                if (ltv[k] - e->weight < ltv[gettop])
                {
                	1tv[gettop] = ltv[k] - e->weight;
              	}
            }
            
            /* 求 ete, lte 和关键活动 */
            for ( j=0; j< GL->numVertexes; j++ ) 
            {
            	for (e = GL->adjList[j].firstedge; e; e = e->next)
            	{
                    k = e->adjvex;
                    ete = etv[j];	/*活动最早发生时间*/
                    Ite = ltv[k] - e->weight;/* 活动最迟发生时间 */
                    if (ete == Ite)	/*两者相等即在关键路径上*/
                    printf ( "<v%d,v%d> length: %d， ", GL->adjList[j).data,GL->adjList(k].data,e->weight);
        		}
        	}
       	}
    }
    /* ete本来是表示活动 <v_k, v_j> 的最早开工时间，是针对弧来说的。但只有此弧的弧尾顶点 v_k 的事件发生了，它才可以开始，因此 ete=etv[k] */
    /* 而 Ite 表示的是活动 <v_k, v_j> 的最晚开工时间，但此活动再晚也不能等巧事件发生才开始，而必须要在vj事件之前发生，所以 lte = ltv[j] - len<v_k, v_j>. 就像你晚上23点睡觉，你不能说到23点才开始做作业，而必须要提前2小时，在21点开始，才有可能按时完成作业。 */
    ```

  * 最终，其实就是判断ete与Ite是否相等，相等意味着**活动没有任何空闲**，是 关键活动，否则就不是。

  * 事件 ei 的最晚开始时间定义为：ei 的后继事件 ej 的最晚开始时间减去 ei 和 ej 之间的活 动的持续时间的差，当 ei 有多个后继事件时，则取这些差值中最小的一个作为 ei 的最晚开始时间。计算顶点Vk即求etv[k]的最早发生时间的公式是：
    $$
    ltv[k]=\begin{cases}
    etv[k], & k = n-1\\
    min\{ltv[j] - len<v_k, v_j>\}, & k < n-1 \&\&<v_k, v_j> \in S[k]
    \end{cases}
    $$

* 求关 键路径算法的时间复杂度依然是0(n+e)o

---

##### 总结回顾

* 图是计算机科学中非常常用的一类数据结构，有许许多多的计算问题都是用图来 定义的。由于图也是最复杂的数据结构，对它讲解时，涉及到数组、链表、栈、队 列、树等之前学的几乎所有数据结构。
* 图的存储结构我们一共讲了五种，其中比较重要的是邻接矩阵和邻接表，它们分别代表着边集是用数组还是链表的方式存储。十字链表是邻接矩阵的一种升级，而邻接多重表则是邻接表的升级。边集数组更多考虑的是对边的关注。 用什么存储结构需要具体问题具体分析，通常稠密图，或读存数据较多，结构修改较 少的图，用邻接矩阵要更合适，反之则应该考虑邻接表。
* 图的遍历分为深度和广度两种，各有优缺点。
* 图的三种应用：最小生成树、最短路径和有向无环图的应用。
  * 最小生成树，我们讲了两种算法：
    * 普里姆（Prim）算法
    * 克鲁斯卡尔（Kruskal） 算法。
    * 普里姆算法像是走一步看一步的思维方式，逐步生成最小生成树。而克鲁斯卡 尔算法则更有全局意识，直接从图中最短权值的边入手，找寻最后的答案。
  * 最短路径的现实应用非常多，我们也介绍了两种算法。
    * 迪杰斯特拉（Dijkstra）算 法更强调单源顶点查找路径的方式，比较符合我们正常的思路，容易理解原理，但算 法代码相对复杂。
    * 弗洛伊德（Fbyd）算法则完全抛开了单点的局限思维方式，巧妙地应用矩阵的变换，用最清爽的代码实现了多顶点间最短路径求解的方案，原理理解 有难度，但算法编写很简洁。
  * 有向无环图时常应用于工程规划中，对于整个工程或系统来说，我们一方面关心 的是工程能否顺利进行的问题，通过拓扑排序的方式，我们可以有效地分析出一个有 向图是否存在环，如果不存在，那它的拓扑序列是什么？另一方面关心的是整个工程 完成所必须的最短时间问题，利用求关键路径的算法，可以得到最短完成工程的工期以及关键的活动有哪些。