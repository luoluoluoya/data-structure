##### 查找概论

* **查找**   查找(Searching)就是根据给定的某个值，在查找表中确定一个其关键字等 于给定值的数据元素(或记录)。
  * 查找表（Search Table）是由同一类型的数据元素（或记录）构成的集合。
  * 关键字（Key）是数据元素中某个数据项的值，又称为键值，用它可以标识一个数据元素。也可以标识一个记录的某个数据项（字段），我们称为关键码.
  * 此关键字可以唯一地标识一个记录，则称此关键字为主关键字（Primary Key）. 注意这也就意味着，对不同的记录，其主关键字均不相同。主关键字所在的数据项称为主关键码.
  * 对于那些可以识别多个数据元素（或记录）的关键字，我们称为次关键字（Secondary Key）。次关键字也可以理解为是不以唯一标识一个 数据元素（或记录）的关键字，它对应的数据项就是次关键码。
* 若表中存在这样的一个记录，则称查找是成功的，此时查找的结果给出整个记录 的信息，或指示该记录在查找表中的位置。若表中不存在关键字等于给定值的记录，则称查找不成功，此时查找的结果可给 出一个“空”记录或“空”指针。
* 静态査找表（Static Search Table）:只作査找操作的查找表。它的主要操作有：
  * 查询某个 “特定的” 数据元素是否在查找表中。
  * 检索某个 “特定的” 数据元素和各种属性。
* 动态査找表(Dynamic Search Table): 在査找过程中同时插入査找表中不存在的 数据元素，或者从査找表中删除已经存在的某个数据元素。显然动态查找表的操作就 是两个：
  * 查找时插入数据元素。
  * 查找时删除数据元素。
* 为了提高査找的效率，我们需要专门为查找操作设置数据结构，这种面向查找操 作的数据结构称为**查找结构**。
  * 从逻辑上来说，查找所基于的数据结构是集合，集合中的记录之间没有本质关系。
  * 可是要想获得较高的查找性能，我们就不能不改变数据元素之间的关系，在存储时可以将查找集合组织成表、树等结构。例如，对于静态查找表来说，我们不妨应用线性表结构来组织数据，这样可以使用顺序査找算法，如果再对主关键字排序，则可以应用折半查找等技术进行高效的查找。如果是需要动态查找，则会复杂一些，可以考虑二叉排序树的查找技术。

---

##### 顺序表查找

* **顺序査找(Sequential Search)**   又叫线性査找，是最基本的查找技术，它的査找过程是：从表中第一个(或最后一个)记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最 后一个(或第一个)记录，其关键字和给定值比较都不等时，则表中没有所查的记 录，查找不成功。

* 顺序查找的算法实现

  ```c
  /* 顺序查找，a为数组，n为要查找的数组个数，key为要查找的关键字*/
  int SequentialSearch (int *a, int n, int key)
  {
      int i;
      for (i=l;i<=n;i++)
      {
          if (a[i] == key)
              return i;
      }
      return 0;
  }
  ```
  * 每次循环时都需要对 i 是否越界，即是否小于等于n 作判断。事实上，还可以有更好一点的办法，设置一个哨兵，可以解决不需要每次让 i  与 n 作比较。

* 顺序表查找优化

  ```
  /*有哨兵顺序查找*/
  int SequentialSearch2 （int *a,int n,int key）
  {
      int i;
      a[O]=key; /*设置a[O]为关键字值，我们称之为“哨兵” */
      i=n;	/*循环从数组尾部开始*/
      while （ a[i] != key ）
      {
      	i--;
      }
      return i; /*返回0则说明查找失败*/
  }
  ```

  * 在查找方向的尽头放置“哨兵”免去了在查找过程中每一次比较后都要判断查找位置是否越界的小技巧，看似与原先差别不大，但在总数据较多时，效率提高很大，是非常好的编码技巧。当然，“哨兵”也不一定就一定要在数组开始，也可以在末端。

* 对于这种顺序查找算法来说，查找成功最好的情况就是在第一个位置就找到了， 算法时间复杂度为 O(1) ,最坏的情况是在最后一位置才找到，需要n次比较，时间复 杂度为 O(n) ，当查找不成功时，需要n+1次比较，时间复杂度为 O(n+1). 我们之前推 导过，关键字在任何一位置的概率是相同的，所以平均查找次数为 O((n+1)/2) ,所以最终 时间复杂度还是 O(n)。

* 很显然，顺序查找技术是有很大缺点的，n 很大时，查找效率极为低下，不过优 点也是有的，这个算法非常简单，对静态查找表的记录没有任何要求，在一些小型数 据的查找时，是可以适用的。另外，也正由于査找概率的不同，我们完全可以**将容易查找到的记录放在前面， 而不常用的记录放置在后面，效率就可以有大幅提高。**

---

##### 有序表查找

* 一个线性表有序时，对于查找总是很有帮助的。

###### 折半査找（Binary Search）技术

* 又称为二分査找。它的**前提是线性表中的记录必须是关键码有序**（通常从小到大有序），**线性表必须采用顺序存储**。折半査找的基 本思想是：在有序表中，取中间记录作为比较对象，若给定值与中间记录的关键字相等，则査找成功；若给定值小于中间记录的关键字，则在中间记录的左半区继续査 找；若给定值大于中间记录的关键字，则在中间记录的右半区继续査找。不断重复上述过程，直到査找成功，或所有查找区域无记录，査找失败为止。

* 折半査找算法实现

  ```c
  /*折半查找*/
  int Binary_Search (int *a, int n, int key)
      int low,high,mid;	
      low=l;	/*定义最低下标为记录首位*/
      high=n;	/*定义最高下标为记录末位*/
      
      while (low<=high )	
      {	
          mid = (low+high)/2		/* 折半 */
          if ( key < a[mid]	)	/*若查找值比中值小*/
          	high = mid-l;	/*最高下标调整到中位下标小一位*/
          else if ( key >a[mid] )	/*若查找值比中值大*/
          	low=mid+l;	/*最低下标调整到中位下标大一位*/
          else	
          	return mid;	/*若相等则说明 mid 即为查找到的位置 */
      }	
  	return 0;	
  }	
  ```
  * 折半査找是一个基于二元比较的决策树， 树叶对应于一个求解结果。每个内部节点对应于一次决策（二元比较）。算法的复杂度 = 求解问题所需的决策次数，即从跟到叶节点的高度。
  * 折半算法的时间复杂度为 O(logn)，它显然远远好于顺序查找的 0(n)  时间复杂度.
  * 由于折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排 序后不再变化，这样的算法已经比较好了。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。

###### 插值查找

* 示例： 要在取值范围。5 ~ 10000之间100个元素从小到大均匀分布的数组中查找5, 我们自然会考虑从数组下标较小的开始查找。

* 对折半查找的查找划分进行改进
  $$
  mid = \tfrac {low + high} {2} = low + \tfrac{1}{2}(high - low)
  $$
  也就是 mid 等于最低下标 low 加上最髙下标 high 与 low 的差的一半。算法科学家们考虑的就是将这个 1/2 进行改进，改进为下面的计算方案：
  $$
  mid = low + \tfrac{key - a[low]}{a[high] - a[low]}(high - low)
  $$

* 插值査找(InterpoMon Search)是根据要査找的关键字key与査找表中最大最小记录的关键字比较后的査找方法，其核心插值的计算公式。应该说， 从时间复杂度来看， 它也是 O(logn)的。 但**对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好得多**。反之，数组中如果分布类似｛0,1,2,2000,2001, 999998, 999999)这种极端不均匀的数据，用插值查找未必是很合适的选择。
* 折半查找是从中间分，也就是说，每一次查找总是一分 为二，无论数据偏大还是偏小，很多时候这都未必就是最合理的做法。除了插值查找，我们再介绍一种有序查找，斐波那契查找(Fibonacci Search),它是利用了黄金分割原理来实现的。

###### 斐波那契查找

*  斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为$F[n]$(如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素)，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。
* 斐波那契查找的时间复杂度还是O(log 2 n )，但是 与折半查找相比，斐波那契查找的优点是它只涉及加法和减法运算，而不用除法，而除法比加减法要占用更多的时间，因此，斐波那契查找的运行时间理论上比折半查找小，但是还是得视具体情况而定。
* 每次取斐波那契数列中的某个值时(F[k])，都会进行-1操作，这是因为有序表数组位序从0开始的，纯粹是为了迎合位序从0开始。

* 算法实现

  ```
  /*斐波那契查找*/	
  int FibonacciSearch (int *a, int n, int key)
  {
      int low,high,mid,i,k;	
      low=l;	/*定义最低下标为记录首位*/
      high=n;	/*定义最高下标为记录末位*/
      k=0;	
      
      /*计算 n 位于斐波那契数列的位置*/
      while ( n > F[k] -1 )	
          k++;
          
      /*将不满的数值补全*/
      for (i=n; i<F[k]-l;i++)
          a[i]=a[n]；	
          
      while (low <= high)	
      {
          mid = low + F[k-1] -1;	/*计算当前分隔的下标*/
          if (key<a[mid]) 	/*若查找记录小于当前分隔记录*/
          {
              high=mid-l;	/*最高下标调祭到分隔下标mid-1处*/
              k = k-l;	/*斐波那奖数列下标减一位*/
          }	
      	else if ( key>a[mid] ) /*若查找记录大于当前分隔记录*/
      	{
              low=mid+l;	/*	最低下标调签到分割下标mid+1处*/
              k = k-2; /*	斐波那契數列下标减两位*/
          }
          else
          {
              if (mid <= n)		
              	return mid;	 /*若相等则说明mid即为查找到的位置*/
              else		
              	return n;	 /*若mid>n说明是补全數位，返回n */
          }
      }
     	return 0;
  }
  /* F[k] = F[k-1] + F[k-2] */
  /**/
  ```

* 斐波那契查找算法的核心在于：

  * 当 key=a[mid] 时，查找就成功；

  * 当 key<a[mid] 时，新范围是第 low 个到第 mid-1 个，此时范围个数为F[k-1]  - 1个；

  * 当 key>a[mid], 新范围是第 m+1个到第high个，此时范围个数为 F[k-2] - 1个。

  ![image-20200425180859708](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20200425180859708.png)

* 如果要查找的记录在右侧，则左侧的数据都不用再判断了，不断反复进行下去，对处于当中的大部分数据，其工作效率要高一些。所以尽管斐波那契查找 的时间复杂也为0(logn),但就平均性能来说，斐波那契查找要优于折半查找。可惜如果是最坏情况，比如 key 始终都处于左侧长半区在查找，则查找效率要低于折半査找。

---

##### 线性索引查找

* 数据结构的最终目的是提高数据的处理速度，索引是为了加快查找速度而设计的 —种数据结构。索引就是把一个关键字与它对应的记录相关联的过程，一个索引由若干个索引项构成，每个索引项至少应包含关键字和其对应的记录在存储器中的位置等信息。索引技术是组织大型数据库以及磁盘文件的一种重要技术。
* 索引按照结构可以分为线性索引、树形索引和多级索引。我们这里就只介绍线性 索引技术。所谓线性索引就是将索引项集合组织为线性结构，也称为索引表。我们重点介绍三种线性索引：稠密索引、分块索引和倒排索引。

###### 稠密索引

* 稠密索引是指在线性索引中，将数据集中的每个记录对应一个索引项。
* 对于稠密索引这个索引表来说，索引项一定是按照关键码有序的排列。索引项有序也就意味着，我们要查找关键字时，可以用到折半、插值、斐波那契等有序查找算法，大大提高了效率。这显然是稠密索引优点，但是如果数据集非常大，比如上亿，那也就意味着索引 也得同样的数据集长度规模，对于内存有限的计算机来说，可能就需要反复去访问磁 盘，查找性能反而大大下降了。

###### 分块索引

* 稠密索引因为索引项与数据集的记录个数相同，所以空间代价很大。为了减少索 引项的个数，我们可以对数据集进行分块，使其分块有序，然后再对每一块建立一个索引项，从而减少索引项的个数。
* **分块有序**，是把数据集的记录分成了若干块，并且这些块需要满足两个条件
  * **块内无序**，即每一块内的记录不要求有序。当然，你如果能够让块内有序对查找来说更理想，不过这就要付出大量时间和空间的代价，因此通常我们不要求块内有序。
  * **块间有序**，例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字，第三块的所有记录的关键字均要大于第二块的所有记录关键字...,因为只有块间有序，才有可能在查找时带来效率。
* 对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做**分块索引**。
* 定义的分块索引的索引项结构分三个数据项
  * **最大关键码**，它存储每一块中的最大关键字，这样的好处就是可以使得在 它之后的下一块中的最小关键字也能比这一块最大的关键字要大
  * 存储了**块中的记录个数**，以便于循环时使用；
  * 用于**指向块首数据元素的指针**，便于开始对这一块中记录进行遍历。

* 在分块索引表中查找，就是分两步进行

  * **在分块索引表中查找要查关键字所在的块**。由于分块索引表是块间有序的， 因此很容易利用折半、插值等算法得到结果。
  * 根据块首指针找到相应的块，并**在块中顺序查找关键码**。因为块中可以是无序 的，因此只能顺序查找。

* 分块索引的性能分析

  * 分析一下分块索引的平均查找长度。设 n 个记录的数据集被平均分成 m 块，每个块中有 t 条记录，显然 n=m*t, 或者说 m=n/t 。再假设$L_b$为查找索引表的平均查找长度，因最好与最差的等概率原则，所以Lb的平均长度为(m+1)/2。$L_w$为块中 查找记录的平均査找长度，同理可知它的平均查找长度为(t+1)/2。这样分块索引查找的平均查找长度为：
    $$
    ASL_w = L_b + L_w = \tfrac{m+1}{2} + \tfrac{t+1}{2} = 1/2(m+t)+1 = 1/2(\tfrac{n}{t}+t)+1
    $$
    注意上面这个式子的推导是为了让整个分块索引查找长度依赖 n 和 t 两个变量。 从这里了我们也就得到，平均长度不仅仅取决于数据集的总记录数 n,还和每一个块 的记录个数 t 相关。最佳的情况就是分的块数 m 与块中的记录数 t 相同，此时意味着 n = m * t = t^2,即
    $$
    ASL_w = 1/2(\tfrac{n}{t} + t) + 1 = \sqrt{n} + 1
    $$
    可见，分块索引的效率比之顺序查找的 O(n) 是高了不少，不过显然它与折半查找 的 O(logn) 相比还有不小的差距。因此在确定所在块的过程中，由于块间有序，所以可 以应用折半、插值等手段来提高效率。总的来说，分块索引在兼顾了对细分块不需要有序的情况下，大大增加了整体查 找的速度，所以普遍被用于数据库表查找等技术的应用当中。

###### 倒排索引

* 索引项的通用结构是：
  * 次关键码  
  * 记录号表
* 记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引（inverted index）。倒排索引源于实际应用中需要根据属性（或字段、次关键码）的值来查找记录。这种索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址。由于不是由记录来确定属性值，而是由属性值来确定记录的位置，因而称为倒排索引。
* 倒排索引的优点显然就是查找记录非常快，基本等于生成索引表后，查找时都不 用去读取记录，就可以得到结果。但它的缺点是这个记录号不定长，维护比较困难，插入和删除操作都需要作相应的处理。

---

##### 二叉排序树

* 假设查找的数据集是普通的顺序存储，那么插入操作就是将记录放在表的末端， 给表记录数加一即可，删除操作可以是删除后，后面的记录向前移，也可以是要删除的元素与最后一个元素互换，表记录数减一，反正整个数据集也没有什么顺序，这样 的效率也不错。应该说，插入和删除对于顺序存储结构来说，效率是可以接受的，但 这样的表由于无序造成查找的效率很低。如果查找的数据集是有序线性表，并且是顺序存储的，查找可以用折半、插值、 斐波那契等查找算法来实现，可惜，因为有序，在插入和删除操作上，就需要耗费大量的时间。
* 二叉排序树（Binary Sort Tree）,又称为二叉査找树。它或者是一棵空树，或者 是具有下列性质的二叉树。
  * 若它的左子树不空，则左子树上所有结点的值均小于它的根结构的值;
  * 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值;
  * 它的左、右子树也分别为二叉排序树。
* 从二叉排序树的定义也可以知道，它前提是二叉树，然后它采用了递归的定义方 法，再者，它的结点间满足一定的次序关系，左子树结点一定比其双亲结点小，右子树结点一定比其双亲结点大。构造一棵二叉排序树的目的，其实并不是为了排序，而是**为了提高查找和插入删除关键字的速度**。不管怎么说，在一个有序数据集上的查找，速度总是要快于无序的数据集的，而二叉排序树这种非线性的结构，也有利于插入和删除的实现。

###### 二叉排序树查找操作

* 二叉树的结构

  ```
  /* 二叉村的二叉链表节点结构定义 */
  typedef struct BiTNode	/* 结点结构 */
  {
      int data;		/*结点数据*/
      struct BiTNode *lchild, *rchild; /* 左右孩子指针 */
  } BiTNode, *BiTree;
  ```

* 二叉排序树的查找算法

  ```
  /*递归查找二叉排序树T中是否存在key*/
  /*指针f指向T的双亲，其初始调用值为NULL */
  /*若查找成功，则指针p指向该数据元索结点，并返回TRUE */
  /*否则指针p指向查找路径上访问的最后一个结点并返回FALSE */
  Status SearchBST(BiTree T, int key, BiTree f, BiTree *p)
  {
  	if	(!T)	/*查找不成功*/
  	{
  		*p = f；
  		return FALSE;
  	} elseif ( key==T->data) /* 查找成功 */
  	{
          *p = T;
          return TRUE;
      } else if ( key < T->data )
      {
          return SearchBST(T->lchild, key, T, p) ;/*在左子树纏续查找 */
      } else {
          return SearchBST(T->rchild, key, T, p) ;/*在右子树继续查找 */
      }
  }
  ```

* 二叉排序树插入操作

  * 所谓的二叉排序树的插入，其实也就是将关键 字放到树中的合适位置而已

  ```
  /*当二叉排序树T中不存在关键字等于key的数据元素时，*/
  /*插入key并返回TRUE.否则返回FALSE */
  
  Status InsertBST (BiTree *T, int key)
  {
      BiTree p,s;
      if ( !SearchBST (*T, key, NULL, &p) ) /* 查找不成功 */ 
      {
          s = ( BiTree ) malloc ( sizeof ( BiTNode ));
          s->data = key;
          s->lchild = s->rchild = null; 
          
          /*插入s为新的根结点*/
          if (!p) {
          	*T = s;
          } else if ( key < p->data)
          {
          	p->lchild = s;
          } else
          {
          	p->rchild = s;
          }
          return TRUE;
      } 
  	return FALSE; /*树中已有关铤字相同的结点，不再插入*/
  }
  ```

* 二叉排序树删除操作

* 我们不能因为删除了结点，而让这棵树变得不满足二叉排序树的特性，所以删除需要考虑多种情况。

  * 删除二叉排序树中叶子结点
    * 删除它们对整棵树来说，其他结点的结构并未受到影响
  * 删除的结点只有左子树或只有右子树的情况
    * 将它的左子树或右子树整个移动到删除结点的位置即可，可以理解为独 子继承父业
  * 要删除的结点既有左子树又有右子树的情况
    * 将被删除节点的左子树的最大节点替换待删除节点（左子树最右节点）
    * 将被删除节点的左子树的最小节点替换待删除节点（右子树最左节点）
    * 中序遍历的前驱和后继节点元素

* 删除算法实现

  ```
  /*若二又排序树T中存在关铤字等于key的数据元素时，则除该数据元素站点，*/
  /*并返回TRUE;否则処回FALSE */
  Status DeleteBST ( BiTree *T, int key)
  {
      if (!*T) /*不存在关键字等于key的数据元* */
          return FALSE;
      else
      {
          if ( key= ( *T ) ->data ) /*找到关键字等于key的数据元*/
              return Delete (T);
          else if ( key < (*T)->data )
              return DeleteBST (&(*T ->lchild,key);
          else
              return DeleteBST (&(*T)->rchild,key );
      }
  }
  /*这段代码和前面的二叉排序树查找几乎完全相同，唯一的区别就在于找到元素时执行的是Delete方法，对当前结点进行删除操作。（可先找到元素，后执行移除）*/
                                
  /*从二又排序树中昌除结点p,并重接它的左或右子树。•/
  Status Delete (BiTree *p)
  {
      BiTree q,s;
      if ((*p) ->rchild = NULL )	/*右子树空則只需重接它的左子树•/
      {
      	q=*p； *p= (*p) ->lchild; free (q);
      }
      elseif ((*p) ->lchild-=NULL ) /* 只需重接它的右子树 */
      {
      	q=*p; *p = (*p ) ->rchild; free (q);
      }
      else	/*左右子树均不空*/
      {
          q=*p； 
          s= ( *p ) ->lchild;
          while (s->rchild)	/* 转左，然后向右到尽头，找持删结点的前驱*/
          {
              q=s; s->rchild; /*s指向被删站点的直接前驱*/
          }
          
          (*p)->data = s->data; 
          if (q != *p)
              q->rchild=s->lchild; /* 重接 q 的右子树•/
          else
              q->lchild=s->lchild; /* 重接 q 的左子树 */
          free (s);
      }
      return TRUE;
  }
  ```

---

###### 二叉排序树总结

* 总之，二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入或删除 操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。插入删除的时间性能比较好。而对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。极端情况，最少为 1 次，即根结点就是要找的结点，最多也不会超过树的深度。也就是说， **二叉排序树的查找性能取决于二叉排序树的形状。可问题就在于，二叉排序树的形状是不确定的。** 例如. 数组元素的次序是从小到大有序，如｛35,37,47,51,58,62,73,88, 93,99｝,则二叉排序树就成了极端的右斜树，注意它依然是一棵二叉排序树。此时，查找结点99,需要10 次比较才可以得到结果。
* 我们希望二叉排序树是比较平衡的，即其深度与完全二叉树相同，均为 $\lfloor log_2n \rfloor + 1$,那么查找的时间复杂也就为 $O(logn)$ 近似于折半查找.
* 不平衡的最坏情况，查找时间复杂度为0（n），这等同于顺序查找。
* 如果我们希望对一个集合按二叉排序树査找，最好是把它构建成一棵平衡的二叉排序树。这样我们就引申出另一个问题，如何让二叉排序树平衡的问题。

---

##### 平衡二叉树（AVL树）

* 平衡二叉树(SMBalancing Binary Search Tree 或 Heigjit-Balanced Binary Search Tree),是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于 1。
* 它是一种高度平衡的二叉排序树。 那什么叫做高度平衡呢？意思是说，要么它是一棵空树，要么它的左子树和右子树都 是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过 1. 
* 将二叉树上结点的左子树深度减去右子树深度的值称为**平衡因子 BF (Balance Factor)**,那么平衡二叉树上所有结点的平衡因子只可能是 -1、0和1。只要二叉树上有一个结点的平衡因子的绝对值大于1,则该二叉树就是不平衡的。
* 距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为 **最小不平衡子树**。
* **平衡二叉树实现原理**

* 平衡二叉树构建的基本思想就是在构建二叉排序树的过程中，每当插入一个结点 时，先检查是否因插入而破坏了树的平衡性，若是，则找出最小不平衡子树。在保持 二叉排序树特性的前提下，调整最小不平衡子树中各结点之间的链接关系，进行相应的旋转，使之成为新的平衡子树。

* 平衡二叉树，其实就是在二叉排序树创建过程中保证它的平衡性，一旦发现有不平衡的情况，马上处理，这样就不会造成不可收拾的情况出现。

* 当最小不平衡子树根 结点的平衡因子BF是大于 1 时，就右旋，小于 -1 时就左旋。插入结点后，最小不平衡子树的 BF 与它的子树的 BF 符号相反时，就需要对结点先进行一次旋转以使得符号相同后，再反向旋转一次才能够完成平衡操作。

* 二叉排序树的结点结构

  ```c
  /*二叉树的二又链表结点结枸定义*/
  typedef struct BiTNode	/*结点结构*/
  {
      int data;	/*结点数据*/
      int bf;	 /*结点的平衡因子*/
      struct BiTNode *lchild,	*rchild;/*左右孩子指针*/
  } BiTNode, *BiTree;	
  ```

* 右旋操作算法

  ```c
  /*对以p为根的二叉排序树作右親处理，*/
  /*处理之后p指向新的树根结点，即旅捋处理之前的左子树的根结点*/
  void R_Rotate (BiTree *P )
  {
      BiTree L;
      L = (*P)->lchild;	/* L指向P的左子树根结点 */
      (*P)->lchild = L->rchild;	/* L的右子树挂接为P的左子树*/
      L->rchild= (*P);
      *P = L; /*P指向新的根结点*/
  }
  /*此函数代码的意思是说，当传入一个二叉排序树P,将它的左孩子结点定义为L, 将L的右子树变成P的左子树，再将P改成L的右子树，最后将L替换P成为根结 点。这样就完成了一次右旋操作*/
  ```

* 左旋操作算法

  ```c
  /* 对以p为根的二叉排序树作左旋处理 */
  /* 处理之后P指向新的树根站点，即旋转处理之前的右子树的根结点 */
  void L_Rotate (BiTree *P)
  {
      BiTree R;
      R = (*P)->rchild;	/* R指向P的右子树根结点*/
      (*P)->rchild = R->lchild; /* R的左子树挂接为P的右子树*/ 
      R->lchild = ( *P);
      *P=R;	/* P指向新的根结点•/
  }
  /*这段代码与右旋代码是对称的*/
  ```

* 左平衡旋转处理的算法

  ```
  #define LH +1	/* 左高 */
  #define EH 0	/* 等高 */
  #define RH -1 /* 右高 */
  /*对以指针T所指結点为根的二叉树作左平街裁转处理*/
  /*本算法站束时，指卄T指向新的根结点•/
  1void LeftBalance (BiTree *T )
  2{
  3BiTree LrLr;
  4( *T)->lchild； /* L指向T的左子树根结点*/
  5switch ( L->bf )
  6{ /*检查T的左子树的平衡度，并作相应平街处理*/
  7case LH: /*新结点插入在T的左孩子的左子树上，要作单右旋处理*/
  8(*T ) ->bf=L->bf-EH;
  9R_Rotate(T);
  10break;
  11case RH: /* 新始点插入在T的左孩子的右子树上，妾作双叢处理*/
  12Lr=L->rchild;	/• Lr指向T的左孩子的右子树根*/
  13switch(Lr->bf ) /*修改T及其左孩子的平衡因子*/
  14(
  15case LH: ( *T) ->bf«RH;
  16L->bf=EH;
  #define LH +1	/* 左高 */
  #define EH 0	/* 等高 */
  #define RH -1 /* 右高 */
  /*对以指针T所指結点为根的二叉树作左平街裁转处理*/
  /*本算法站束时，指卄T指向新的根结点•/
  1void LeftBalance (BiTree *T )
  2{
  3BiTree LrLr;
  4( *T)->lchild； /* L指向T的左子树根结点*/
  5switch ( L->bf )
  6{ /*检查T的左子树的平衡度，并作相应平街处理*/
  7case LH: /*新结点插入在T的左孩子的左子树上，要作单右旋处理*/
  8(*T ) ->bf=L->bf-EH;
  9R_Rotate(T);
  10break;
  11case RH: /* 新始点插入在T的左孩子的右子树上，妾作双叢处理*/
  12Lr=L->rchild;	/• Lr指向T的左孩子的右子树根*/
  13switch(Lr->bf ) /*修改T及其左孩子的平衡因子*/
  14(
  15case LH: ( *T) ->bf«RH;
  16L->bf=EH;
  }
  }
  ```

  // todo....