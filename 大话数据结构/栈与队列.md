* 栈与队列:
  * 栈是限定仅在表尾进行插入和删除操作的线性表。
  * 队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。

---

#### 栈

* 栈这种后进先岀数据结构的应用是非常普遍的。
  * 比如你用浏 览器上网时，不管什么浏览器都有一个“后退”键，你点击后可以按访问顺序的逆序 加载浏览过的网页
  * 很多类似的软件，比如Word、Photoshop等文档或图像编辑软件中，都有撤销 (und>)的操作，也是用栈这种方式来实现的
* 栈(stack )是限定仅在表尾进行插入和删除操作的线性表。
  * 把允许插入和删除的一端称为栈顶(top),另一端称为栈底(bottom),不含任何数据元素的栈称为空栈。栈又称为后进先出(Last In First Out)的线性表，简 称LIFO结构。
  * 首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。
  * 过它是一种特殊的线性表。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。它的特殊之处就在于限制了这个线性表的插入和删除位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。
  * 栈的插入操作，叫作进栈，也称压栈、入栈。
  * 栈的删除操作，叫作出栈，也有的叫作弹栈。

* 栈的抽象数据类型

  ```
  ADT 栈(stack)
  Data
  	同线性表。元素具有相同的类型，相邻元素具有前驱和后継关系。
  Operation
    InitStack ( *S):初始化操作，建立一个空栈S。
    DestroyStack ( *S ):若栈存在，則销毁它。
    ClearStack ( *S)：将栈清空。
    StackEmpty ( S )：若栈为空，返回true,否则返回false。
    GetTop (S,*e):若栈存在且非空，用e返回S的栈顶元素。
    Push (*Sze):若栈S存在，插入新元素e到栈S中并成为栈顶元素。
    Pop (*S,*e):測除桟S中栈顶元素，并用e返回*值。
    StackLength(S):返回栈S的元素个数。
  endADT
  ```

* 栈的顺序存储结构

  * 栈是线性表的特例，那么栈的顺序存储其实也是线性表顺序存储的简化，我们简称为**顺序栈**。线性表是用数组来实现的

    * 下标为 0 的一端作为栈底比较好，因为首元素都存在栈底，变化最小，所以让它作栈底。

    ```
    typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */
    typedef struct
    {
      SElemType data(MAXSIZE];
      int top;	/*用于栈顶指针*/
    } SqStack;
    ```

  * 进栈操作

    ```
    
    ```

  * 出栈操作

    ```
    
    ```

  * 两栈共享空间

    * 其实栈的顺序存储还是很方便的，因为它只准栈顶进出元素，所以不存在线性表 插入和删除时需要移动元素的问题。不过它有一个很大的缺陷，就是必须事先确定数 组存储空间大小，万一不够用了，就需要编程手段来扩展数组的容量，非常麻烦。对 于一个栈，我们也只能尽量考虑周全，设计岀合适大小的数组来处理，但对于两个相 同类型的栈，我们却可以做到最大限度地利用其事先开辟的存储空间来进行操作。
    * 如果我们有两个相同类型的栈，我们为它们各自开辟了数组空间， 极有可能是第一个栈已经满了，再进栈就溢出了，而另一个栈还有很多存储空间空闲。
    * 数组有两个端点，两个栈有两个栈底，让一个栈的栈底为 数组的始端，即下标为0处，另一个栈为栈的末端，即下标为数组长度n-1处。这 样，两个栈如果增加元素，就是两端点向中间延伸。
    * 它们是在数组的两端，向中间靠拢。topi和top2是栈1和栈2 的栈顶指针，可以想象，只要它们俩不见面，两个栈就可以一直使用。
    * 栈1为空时，就是top1等于 -1 时；而当 top2 等于 n时，即是栈2为空时

---

```
/*两栈共享空间结构*/
typedef struct
{
    SElemType data[MAXSIZE];
    int topi; /*栈1栈顶指针*/
    int top2; /*栈2栈顶指针*/
} SqDoubleStack;
```

* 用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也 就是一个栈增长时另一个栈在缩短的情况。这样使用两栈共享 空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而 溢出了。
* 这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相 同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂.

---

* 栈的链式存储结构及实现

  * 把栈顶放在单链表的头部
  * 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如 果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是 否溢出的问题。
  * 对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL 的时候。

  ```
  链栈的结构代码如下：
  typedef struct StackNode
  (
      SElemType data;
      struct StackNode *next;
  } StackNode,*LinkStackPtr;
  
  typedef struct Linkstack
  {
      LinkStackPtr top;
      int count;
  } Linkstack;
  ```

  * 进栈操作

    ```
    /*插入元素e为新的栈顶元素*/
    Status Push ( Linkstack *S, SElemType e)
    (
        LinkStackPtr s= ( LinkStackPtr ) malloc ( sizeof ( StackNode )); 
        s->data=e;
        s->next=S->top;/*把当前的栈顶元素賊值给新结点的直接后继，如图中①•/
        S->top=s; /*将新的结点s赋值给栈顶指针，如图中②*/
        S->count++；
        return OK;
    }
    ```

  * 出栈操作

    ```
    /*若栈不空，则删除S的栈顶元素，用e返回其值，并返回0K;否则返回ERROR */ Status Pop(Linkstack *S,SElemType *e)
    {
        LinkStackPtr p;
        if (StackEmpty ( *S ))
            return ERROR;
        *e=S->top->data;
        p=S->top;	/*将桟顶结点赋值给p,如图③*/
        S->top=S->top->next; /*使得栈顶指针下移一位，指向后一结点，如图④•/ 	   free (p) ;	/* 释放结点 p */
        S->count——;
        return OK;
    }
    ```

* 对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为0(1)。对于空间性 能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些 内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，如果栈 的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之,如果它的变化在可控范围内，建议使用顺序栈会更好一些。

---

* 栈的作用

  * 用数组或链表直接实现功能不就行了吗？干吗要引入栈这 样的数据结构呢？

    * 栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。所以现在的许多高级语言，比如Java、C#等都有对栈结构的封装，你可以不用关 注它的实现细节，就可以直接使用Stack的push和pop方法，非常方便。

  * 递归

    * 递归定义    在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。
    * 写递归程序最怕的就是陷入永不结束的无穷递归中，所以，每个递归定义 必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。
    * 迭代和递归的区别是：
      * 迭代使用的是循环结 构，递归使用的是选择结构。
      * 递归能使程序的结构更清晰、更简洁、更容易让人理 解，从而减少读懂代码的时间。
      * 大量的递归调用会建立函数的副本，会耗费大量 的时间和内存。迭代则不需要反复调用函数和占用额外的内存。
    * 递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。
    * 在递归前行阶段，对于每一层递归，函数的局部变量、参数值以及返 回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹 出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。

  * 栈的应用一四则运算表达式求值

    * 后缀（逆波兰）表示法定义

      * 括号都是成对出现的，有左括号就一定会有右括号，对于多 重括号，最终也是完全嵌套匹配的。这用栈结构正好合适，只有碰到左括号，就将此 左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号 时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右 巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈的结果。

      * 后缀表达式计算结果

        ```
        
        ```

      * 中缀表达式转后缀表达式

        * 规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后 缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低 于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直 到最终输出后缀表达式为止。

        ```
        
        ```

---

* 队列的定义

  * 队列(queue )是只允许在一端进行插入操作，而在另一端进行删除操 作的线性表。

  * 队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一 端称为队尾，允许删除的一端称为队头。

  * 队列的抽象数据类型

    ```
    ADT 队列(Queue)
    Data
        同线性表。元素具有相同的类型，相邻元素具有前曝和后继关系。
    Operation
        InitQueue ( *Q ):初始化操作，建立一个空队列Q。
        DestroyQueue ( *Q):若队列Q存在，则销毁它。
        ClearQueue ( *Q)：将队列 Q 清空。
        QueueEmpty ( Q ):若队列Q为空，返回true,否则返回false。
        GetHead(Q,*e)：若队列Q存在且非空，用e返回队列Q的队头元素。
        EnQueue ( *Q,e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
        DeQueue (*Q,*e):删除队列Q中队头元*,并用e返回其值° 		     QueueLength ( Q):返回队列Q的元素个数
    endADT
    ```

* 队列顺序存储

  * 我们假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，并 把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的 入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为0(1),

  * 与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着， 队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为 空，此时时间复杂度为0(n)

  * 如果不去限制队列的元素必须 存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需 要一定在下标为0的位置

  * 为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指 针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等 于rear时，此队列不是还剩一个元素，而是空队列。

  * 假设是长度为5的数组，初始状态，空队列，front与 rear指针均指向下标为0的位置。然后入队a1、a2,  a3,  a4, front指针依然指向下标 为0位置，而rear指针指向下标为4的位置.出队a1、a2,则front指针指向下标为2的位置，rear不变。接着入队a6,将它放置于下标为0处，rear指针指向下标为1处。若再入队a7, 则rear指针就与front指针重合，同时指向下标为2的位置.

    * 置一个标志变量flag
    * front = rear,当队列满时，我们修改其条 件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。

  * 假溢出: 因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在前端的地方还是空闲的。我们把这种现象叫做“假溢出。解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。 我们把队列的这种头尾相接的顺序存储结构称为循环队列.

  * 循环队列满时的判定公式

    ```
    
    ```

  * 循环队列元素个数的判定公式

    ```
    
    ```

  * 循环队列的顺序存储结构代码如下：

    ```
    typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */ 
    /*循环队列的顺序存储结构*/
    typedef struct
    {
        QElemType data[MAXSIZE];
        int front;/* 头指针 */
        int rear;/*尾指针，若队列不空，指向队列尾元素的下一个位JL */
    
    } SqQueue;
    ```

* 单是顺序存储，若不是循环队列，算法的时间性 能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下 不需要担心队列长度的链式存储结构。

---

* 队列的链式存储结构及实现

* 队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已， 我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点, 空队列时，front和rear都指向头结点

* 链队列的结构为：

  ```
  typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */
  
  typedef struct QNode /* 结点结构 */
  {
      QElemType data;
      struct QNode *next;
  } QNode,*QueuePtr;
  
  typedef struct	/*队列的链表结构*/
  {
  	QueuePtr front, rear; /* 队头、队尾指卄 */
  } LinkQueue;
  ```

* 队列的链式存储结构——入队操作

  * 入队操作时，其实就是在链表尾部插入结点

* 队列的链式存储结构——出队操作

  * 岀队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点, 若链表除头结点外只剩一个元素时，则需将rear指向头结点

* 对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基 本操作都是常数时间，即都为0(1)的，不过循环队列是事先申请好空间，使用期间不 释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频 繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所 以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一 个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵 活。总的来说，在可以确定队列长度最夹值的情况下，建议用循环队列，如果你无法 预估队列的长度时，则用链队列。

---

* 栈和队列，它们都是特殊的线性表， 只不过对插入和删除操作做了限制。
* 栈(stack)是限定仅在表尾进行插入和删除操作的线性表。
* 队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性 表。
* 它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。 因此它们各自有各自的技巧来解决这个问题。
  * 对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法 来让两个栈共享数据，这就可以最大化地利用数组的空间。
  * 对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队 列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是0(n)的时间复杂度变成了 0(1)。
  * 它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同