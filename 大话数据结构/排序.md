

#### 排序的基本概念与分类

* 假设含有 n 个记录的序列为 $r_1,r_2,r_3,...,r_n$,其相应的关键字分别为如 $k_1,k_2,k_3,...,k_n$,需确定$r_1,r_2,r_3,...,r_n$的一种排列$p_1,p_2,p_3,...,p_n$, 使其相应的关键字满足$$k_{p1} \le k_{p2} \le k_{p 3}  \le ...  \le  k_{pn}$$（非递减或非递增）关系，即使得序列成为一个按关键字有序的序列 $$r_{p1}, r_{p2}, r_{p 3}, ...  , r_{pn}$$,这样的操作就称为排序。
  * 在排序问题中，通常将数据元素称为记录。显然我们输入的是一个记录集合，输岀的也是一个记录集合，所以说，可以将排序看成是线性表的一种操作。
  * 排序的依据是关键字之间的大小关系，那么，对同一个记录集合，针对不同的关键字进行排序，可以得到不同序列。
  * 关键字虹可以是记录r的主关键字，也可以是次关键字，甚至是若干数据项 的组合。
  * 多个关键字的排序最终都可以转化为单个关键字的排序, 因此，我们这里主要讨论的是单个关键字的排序。
* 由于排序不仅是针对主关键字，那么对于次关键字，因为待排序的记录序 列中可能存在两个或两个以上的关键字相等的记录，排序结果可能会存在不唯一的情 况
* 排序的稳定性
  * 假设 $k_i = k_j (1 \le i \le n, 1 \le j \le n, i\neq j)$ . 且在排序前的序列中$r_i$领先于$r_j$（即$i \le j$)。 如果排序后$r_i$仍领先于$r_j$则称所用的排序方法是稳定的；反之，若可能使得排序后的序列中$r_j$领先$r_i$则称所用的排序方法是不稳定的
    * 只要有一组关键字实例发生类似情况， 就可认为此排序方法是不稳定的。
    * 排序算法是否稳定的，要通过分析后才能得出。
* 内排序与外排序
  * 根据在排序过程中待排序的记录是否全部被放置在内存中，排序分为：内排序和 外排序。
  * 内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。外排序是 由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多 次交换数据才能进行。
* 排序算法的性能
  * 时间性能
    * 排序是数据处理中经常执行的一种操作，往往属于系统的核心部分，因此排序算 法的时间开销是衡量其好坏的最重要的标志。在内排序中，主要进行两种操作：比较 和移动。比较指关键字之间的比较，这是要做排序最起码的操作。移动指记录从一个 位置移动到另一个位置，事实上，移动可以通过改变记录的存储方式来予以避免（这 个我们在讲解具体的算法时再谈）。总之，高效率的内排序算法应该是具有尽可能少的 关键字比较次数和尽可能少的记录移动次数。
  *  辅助空间
    * 评价排序算法的另一个主要标准是执行算法所需要的辅助存储空间。辅助存储空 间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。
  * 算法的复杂性
    * 注意这里指的是算法本身的复杂度，而不是指算法的时间复杂度。显然算法过于 复杂也会影响排序的性能。

* 排序用到的结构与函数

  * 顺序表结构

    ```
    #define MAXSIZE 10	/*用于要排序数组个数最大值，可根据需要修改*/
    typedef struct
    {
      int r[MAXSIZE+l]; /*用于存储要排序教組，r[0] 用作哨兵或临时变量*/ 
      int length;	/*用于记录顺序表的长度*/
    } SqList;
    
    /*另外，由于排序最最常用到的操作是数组两元素的交换，我们将它写成函数，在之后的讲解中会大量的用到。*/
    
    /*交换L中数组工的下标为i和j的值*/
    void swap ( SqList *L, int i, int j )
    (
      int temp = L->r[i];
      L->r[i] = L->r[j];
      L->r[j] = temp;
    }
    ```

---

#### 冒泡排序

* 简单排序实现: 冒泡排序(Bubble Sort)一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。(逆序对)

* 冒泡排序算法实现

  ```
  
  ```

* 冒泡排序优化

  * 当某次遍历没有任何数据交换，这就说明此序列已经有序，不需要再继续后面的循环判断工作了，可以避免因已经有序的情况下的无意义循环判断。

* 冒泡排序优化算法实现

  ```
  
  ```

* 冒泡排序复杂度分析
  * 当最好的情况，也就是要排序的表本身就是有序的， 那么我们比较次数，根据最后改进的代码，可以推断出就是 n-1次的比较，没有数据交换，时间复杂度为O(n)。当最坏的情况，即待排序表是逆序的情况，此时需要比较了$\sum _{i=2}^n {n-i} = (n-1)+...+3+2+1 = n(n-1)/2$次，并作等数量级的记录移动。因此，总的时间复杂度为 O(n^2)。

---

#### 简单选择排序

* 冒泡排序的思想就是不断地在交换，通过交换完成最终的排序。我们可不可以在排序时找到合适的关键字再做交换，并且只移动一次就完成相应关键字的排序定位工作。

* 选择排序的基本思想是每一趟在 n-1+1 (i = 1,2,...,n-1) 个记录中选取关键字最小的记录作为有序序列的第 i 个记录。

* 简单选择排序法(Simple Selection Sort) 就是通过 n-i 次关键字间的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i (1 <= i <= n)个记录交换之。

* 简单选择排序法算法实现

  ```
  
  ```

* 简单选择排序复杂度分析
  * 从简单选择排序的过程来看，它最大的特点就是交换移动数据次数相当少，这样也就节约了相应的时间。分析它的时间复杂度发现，无论最好最差的情况，其比较次数都是一样的多，第 i 趟排序需要进行 n-i 次关键字的比较,此时需要比较 $\sum _{i=1}^{n-1}(n-i) = n-1 + n-2 + ... + 1 = n(n-1)/2$次。而对于交换次数而言，当最好的时候，换为0次，最差的时候，也就初始降序时，交换次数为 n-1 次，基于最终的排序时间 是比较与交换的次数总和，因此，总的时间复杂度依然为0(n^2)。应该说，尽管与冒泡排序同为0(n^2)，但简单选择排序的性能上还是要略优于冒泡排序。

---

#### 直接插入排序

* 直接插入排序(Straight Insertion Sort)的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。

* 算法实现

  ```
  /*利用哨兵*/
  ```

* 直接插入排序复杂度分析
  * 分析一下这个算法，从空间上来看，它只需要一个记录的辅助空间，因此关键是看它的时间复杂度。
  * 当最好的情况，也就是要排序的表本身就是有序的，比如 {2,3,4,5,6}, 那么我们比较次数，其实就是代码每个 L[i] 与 L[i-1] 的比较， 共比较了 n-1 次，由于每次都是 L[i] > L[i-1], 因此没有移动的记录，时间复杂度为O(n).
  * 当最坏的情况，即待排序表是逆序的情况，比如{6,5,4,3,2}, 此时需要比较$\sum_{i=2}^ni = 2 + 3 + ... + n = (n+2)(n-1)/2$次，而记录的移动次数也达到最大值 $\sum_{i=2}^n{i+1} = (n+4)(n-1)/2$次。
  * 如果排序记录是随机的，那么根据概率相同的原则，平均比较和移动次数约为 n^2/4 次。因此，我们得出直接插入排序法的时间复杂度为O(n^2)。从这里也看出，同样的 O(n^2) 时间复杂度，直接插入排序法比冒泡和简单选择排序的性能要好一些。

---

#### 希尔排序

* 希尔排序是D.LShell于1959年 提出来的一种排序算法，在这之前排序算法的时间复杂度基本都是0(n^2)的，希尔排 序算法是突破这个时间复杂度的第一批算法之一。

* 直接插入排序，它的效率在某些时候是很高的，比如， 我们的记录本身就是基本有序的，我们只需要少量的插入操作，就可以完成整个记录 集的排序工作，此时直接插入很高效。还有就是记录数比较少时，直接插入的优势也 比较明显。可问题在于，两个条件本身就过于苛刻，现实中记录少或者基本有序都属 于特殊情况。

  * 元素基本有序
  * 元素基数较少

* 如何让待排序的记录个数较少呢

  * 很容易想到的就是将原本有大量记录数的记录 进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然 后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。
  * 所谓的基本有序，就是小的关键字基本在前面，大的基本在后面，不大不小 的基本在中间，像{2,1,3,6,4,7,589}这样可以称为基本有序了。但像{1,5,9,3,7,8,2,4,6} 这样的9在第三位，2在倒数第三位就谈不上基本有序。
    * 小元素大体在前面， 大元素大体在后面

* 我们分割待排序记录的目的是减少待排序记录的个数，并 使整个序列向基本有序发展。我们需要采取跳跃分割的策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不 是局部有序。

  * 增量为 1 时，所有元素都分配到一个子序列中。（对所有元素执行插入排序）
  * 对每个子序列执行插入排序并非各自独立完成，而是交替执行

* 算法实现

  ```
  *对顺序表L作希尔排序•/
  1void ShellSort (SqList *L )
  2(
  3int i/j;
  4int increment=L->length;
  5do
  6(
  7increment=increment/3+l；	/* 增量序列 */
  8for (i=increment+l;i<=L->length;i++ )
  9I
  10if (L->r[i]<L->r[i-increment])
  11{/*需将L->r[i]插入有序増量子;t */
  12L->r[0]-L->r[i];	/* 暂存在 L->r[0] */
  13for (j-i-increment;j>0&&L->r[0]<L->r[j];j-«=increment)
  14L->r [ j+increment] =L->r [ j ]; / *记录后移，查找插入位置 */
  15L->r [ j+increment] =L->r [0] ; /* 插入 */
  16)
  17}
  18}
  19while ( increment>l);
  20}
  ```

  ```
  void ShellSort (SqList *L)
  {
  	int i,j;
  	int incr = L->length;
  	do {
  		incr = incr / 3 + 1; /*相隔 3 作为子序列*/
  		for (i = incr + 1; i < L->length; i++) {
  			if (L->r[i] < L->r[i-incr]) {
  				L->r[0] = L->r[i];  /*设置哨兵*/
  				/*在当前子序列内执行插入排序*/
  				for (j = i - incr; j>0 && L->r[o] < L->r[j]; j-=incr) {
  					L->r[j+incr] = L->r[0];
  				}
  				L->r[j+incr] = L->r[0];
  			}
  		}
  	} while(incr > 1);
  }
  ```

  

* 希尔排序的关键并不是随便分组后各自排序，而是将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得 排序的效率提高。这里“增量'‘的选取就非常关键了。可究竟应该选取什么样的增量才是最好，目前还 是一个数学难题，迄今为止还没有人找到一种最好的增量序列。需要注意的是，增量序列的最后一个增量值必须等于1才行。另外由于记录是跳跃式的移动，希尔排序并不是一 种稳定的排序算法。
* 希尔排序的复杂度和增量序列是相关的
  * {1,2,4,8,...}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n^2)
  * Hibbard提出了另一个增量序列{1,3,7，...,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^1.5)
  * Sedgewick提出了几种增量序列，其最坏情形运行时间为O（n^1.3）,其中最好的一个序列是{1,5,19,41,109,...}