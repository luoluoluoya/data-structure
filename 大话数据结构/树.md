* 树
  * 树(Tree)是n (n >= 0)个结点的有限集。
  * n = 0 时称为空树。
  * 在任意一棵非空树中：
    1. 有且仅有一个特定的称为根(Root)的结点. 根结点是唯一的，不可能存在多个根结点，
    2. 当n>1时，其 余结点可分为m (m>0)个**互不相交**的有限集T1、T2、……、Tm,其中毎一个 集合本身又是一棵树，并且称为根的子树(SubTree).
       * 子树与根结点必定连通。若子树之间连通， 则必定存在回路。
* 树的结点包含一个数据元素及若干指向其子树的分支。
* 结点拥有的子树数称为结点的度（Degree）。度为0的结点称为叶结点（Leaf）或终端结点。
* 度不为0的结点称为非终端结点或分支结点。**除根结点之外，分支结点也称为内部结点**。
* 树的度是树内各结点的度的最大值。

---

* 结点的子树的根称为该结点的孩子（Child）,相应地，该结点称为孩子的双亲 （Parent）

* 同一个双亲的孩子之间互称兄弟（Sibling）。 

* 结点的祖先是从根到该结点所经分支上的所有结点。

* 以某结点为根的子树中的任一结点都称为该结点的子孙。

* 结点的层次(Level)从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第1层，则其子树的根就在第1+1层。其双亲在同一层的结点互为堂兄弟。

* 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。

* 森林(Forest)是m (m>0)棵互不相交的树的集合。 （简单不连通图）

* 线性结构和树结构的对比

  ```
  
  ```

---

* 树的抽象数据类型

  ```
  ADT 树(tree )
  Data
  	树是由一个根结点和若干棵子树构成。树中结点具有相同数据类型及层次关系。 (不存在回路的简单连通图)
  Operation
  	InitTree ( *T)：构造空树 T。
    DestroyTree ( *T )：销毁树 To
    CreateTree ( *T, definition ):按 definition 中给出树的定义来构造树。
    ClearTree ( *T)：若树T存在，则将树T清为空树。
    TreeEmpty ( T )：若T为空树，返回true,否则返回falseo
    TreeDepth ( T ):返回T的深度。
    Root(T):返回T的根结点。
    Value ( T, cur_e ) : cur_e是树T中一个结点，返回此结点的值。
    Assign ( Tr cur_e, value ):给树 T 的结点 cur_e 赋值为 value。
    Parent (T, cur_e ):若cur_e是树T的非根结点，則返回它的双亲，否则返回空。 
    Leftchild(T,cur_e):若是树T的非叶结点，则返回它的最左孩子，否则返回空。 
    Rightsibling(T,cur_e):若cur_e有右兄弟.则返回它的右兄弟，否则返回空。
    Insertchild ( *T, *p, i, c )：其中p指向树T的某个结点，i为所指结点p的度加上1, 非空树c与T不相史，操作结果为插入c为树T中p指结点的第i棵子树。
    DeleteChild（*T， *p, i）: 其定p指向树T的某个结点，i为所指结点p的度，操作结果为删除T中p所指结点的第i棵子树。
  endADT
  ```

---

* 树的存储结构
  * 用一段地址连续的存储单元依次存储线性表的数据元 素。这对于线性表来说是很自然的，对于树这样一多对的结构. 树中某个结点的孩子可以有多个，这就意味着，无论按何种顺序将树中所有结点 存储到数组中，结点的存储位置都无法直接反映逻辑关系，数据元素挨个 的存储，谁是谁的双亲，谁是谁的孩子呢？简单的顺序存储结构是不能满足树的实现 要求的。不过充分利用顺序存储和链式存储结构的特点，完全可以实现对树的存储结构的表示。

---

* 一 个存储结构设计得是否合理，取决于基于该存储结构的运算是否适合、是否方便，时 间复杂度好不好等。

* 双亲表示法

  * 除了根结点外，其余每个结点，它不一定有孩子，但是一定有且仅有一个双亲。我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。也就是说，每个结点除了知道自己是谁以外，还知道 它的双亲在哪里。

    ```
  /*树的双亲表示法结点結构定义*/
  #define MAX_TREE__SIZE 100
  typedef int TElemType; /*树结点的数据类型，目前暂定为整型*/
  typedef struct PTNode /* 节点结构 */
  {
    TElemType data;
    int parent;  	//双亲位置 /**游标？**/
  }
  
  typedef struct {
    PTNode nodes [MAX_TREE__SIZE] ; /* 结点数姐 */ 
    int r, n; /*根的位置和结点数*/
  } PTree;
  // 由于根结点是没有双亲 的，所以我们约定根结点的位置域设置为一 1,这也就意味着，我们所有的结点都存 有它双亲的位置。
    ```

  * 复杂度
    * 可以根据结点的parent指针很容易找到它的双亲结点，所 用的时间复杂度为0(1),直到parent为 -1 时，表示找到了树结点的根。
    * 要知道结点的孩子是什么，对不起，请遍历整个结构才行。
  * 增加一个结点最左边孩子的域，不妨叫它长子域，这样就可以很 容易得到结点的孩子。如果没有孩子的结点，这个长子域就设置为 -1
  * 增加一个右兄弟域来体现兄弟关系，也就是说，每一 个结点如果它存在右兄弟，则记录下右兄弟的下标。同样的，如果右兄弟不存在，则赋值为 -1

* 孩子表示法

  * 每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这 种方法叫做多重链表表示法。树的每个结点的度，也就是它的孩子个数是不同的。

    * 一种是指针域的个数就等于树的度
      * 这种方法对于树中各结点的度相差很大时，显然是很浪费空间的，因为有很多的结点，它的指针域都是空的。不过如果树的各结点度相差很小时，那就意味着开辟的 空间被充分利用了，这时存储结构的缺点反而变成了优点。
    * 每个结点指针域的个数等于该结点的度，专门取一个位置来存储 结点指针域的个数
      * data为数据域
      * degree为度域，也就是存储该结点的孩子结点的个数
      * child1到childn为指针域，指向该结点的各个孩子的结点。
      * 克服了浪费空间的缺点，对空间利用率是很高了，但是由于各个结点 的链表是不相同的结构，加上要维护结点的度的数值，在运算上就会带来时间上的损耗。 

  * 把每个结点的孩子结点排列起来， 以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构,存放进一个一维数组中.（邻接矩阵）

    * 数据结构

      ```
      /*树的孩子表示法结构定义*/
      # define MAX_TREE_SIZE 100
      typedef struct CTNode/* 孩子结点 */
      {
        int child; /* 当前孩子节点游标 */
        struct CTNode *next; /*兄弟节点地址*/
      } *ChildPtr;
      
      typedef struct	/* 表头结构 */
      (
        TElemType data;
        ChildPtr firstchild;
      } CTBox;
      
      typedef struct	/* 树结构 */
      (
        CTBox nodes [MAX_TREE_SIZE]; /* 站点数组 */
        int r, n;	/*根的位置和结点数/
      } CTree;
      ```

    * 这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需 要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。但是，这也存在着问题，我如何知道某个结点的双亲是谁呢？比较麻烦，需要整棵树遍历才行.

* 双亲孩子表示法

  ```
  
  ```

* 孩子兄弟表示法

  * 任意一棵树，它的结点的第一个孩子如果存在就是唯一 的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。

    ```
    // 其中data是数据域，firstchild为指针域，存储该结点的第一个孩子结点的存储地 址，rightsib是指针域，存储该结点的右兄弟结点的存储地址。
    /*树的孩子兄弟表示法结构定义*/
    typedef struct CSNode
      TElemType data;
      struct CSNode *firstchild,*rightsib;
    } CSNode,*CSTree;
    ```

  * 查找某个结点的某个孩子带来了方便，只需要通过fistchild找到 此结点的长子，然后再通过长子结点的rightsib找到它的二弟，接着一直下去，直到 找到具体的孩子。
  * 如果想找某个结点的双亲，这个表示法也是有缺陷的. 如果真的有必要，完全可以再增加一个parent指针域来解决快速查找 双亲的问题
  * **孩子兄弟表示法表示法的最大好处是它把一棵复杂的树变成了一棵二叉树**

---

* 二叉树（Binaiy Tree ）是 n （ n >= 0 ）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。
* 二叉树特点
  *  每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。注意不是只有两棵子树，而是最多有. 没有子树或者有一棵子树都是可以的。
  * 左子树和右子树是有顺序的，次序不能任意颠倒。
  * 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。
* 二叉树具有五种基本形态：
  * 空二叉树。
  * 只有一个根结点。
  * 根结点只有左子树。
  * 根结点只有右子树。
  * 根结点既有左子树又有右子树。

---

* 特殊二叉树

  * 斜树

    * 所有的结点都只有左子 树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜 树。
    * 斜树有很明显的特点，就是每 一层都只有一个结点，结点的个数与二叉树的深度相同。
    * 线性表结构就可以理解为是树的一种极其特殊的表现形式。

  * 满二叉树

    * 在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在 同一层上，这样的二叉树称为满二叉树。
    * 叶子只能出现在最下一层。出现在其他层就不可能达成平衡。
    * 非叶子结点的度一定是2。
    * 在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。

  * 完全二叉树

    * 对一棵具有n个结点的二叉树按层序编号，如果编号为 i (1<= i <= n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树
    * 满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的。
    * 叶节点只能出现在最下两层中。
    *  最下层的叶子一定集中在左部连续位置。
    * 倒数二层，若有叶子结点，一定都在右部连续位置。
    *  如果结点度为1,则该结点只有左孩子，即不存在只有右子树的情况。
    * 同样结点数的二叉树，完全二叉树的深度最小。

  * 判断某二叉树是否是完全二叉树

    ```
    
    ```

---

* 二叉树的性质
  * 在二叉树的第i层上至多有2^(i-1)个结点 (i >= 1).
  * 深度为k的二叉树至多有2^k  - 1个结点 (k>=1).
  * 任何一棵二叉树T,如果其终端结点数为中n0，度为2的结点数n2, 则 n0 = n2 + 1.
    * 终端结点数其实就是叶子结点数，而一棵二叉树，除了叶子结点外，剰下的就是 度为1或2的结点数了，我们设n1为度是1的结点数。则树T结点总数 n=n0+n1+n2.
  * 具有n个节点的完全二叉树的深度为 $\lfloor logn \rfloor + 1$

* 二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。
  * 完全二叉树由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。(层序编号反映逻辑关系)
    * 考虑一种极端的情况，一棵深度为k的右斜树，它只有k个结点，却需要分配 2^k -1 个存储单元空间，这显然是对存储空间的浪费。 所以，顺序存储结构一般只用于完全二叉树。

---

* 二叉链表

* 二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的 链表叫做**二叉链表**。

  ```
  /*二叉树的二又链表结点結构定义*/
  typedef struct BiTNode /* 结点结构 */
  {
    TElemType data;	/* 结点数据 */
    struct BiTNode *lchild, *rchild; /* 左右孩子指针 */
  } BiTNode, *BiTree;
  ```
  * 就如同树的存储结构中讨论的一样，如果有需要，还可以再增加一个指向其双亲的指针域，那样就称之为**三叉链表**。

---

* 二叉树遍历原理

  * 二叉树的遍历(traversing binary tree )是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。
  * 二叉树的遍历次序不同于线性结构，最多也就是从头至尾、循环、双向等简单的 遍历方式。树的结点之间不存在唯一的前驱和后继关系，在访问一个结点后，下一个被访问的结点面临着不同的选择。
    * 决策

*  前序遍历

  * 规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子

    树，再前序遍历右子树。

    ```
    /*二叉树的前序遍历递归算法*/
    void PreOrderTraverse (BiTree T)
    {
      if (T==NULL)
        return;
      printf ("%c",T->data) ;/*显示结点数据，可以更改为其他对结点操作*/ 
      PreOrderTraverse ( T->lchild ) ; /* 再先序過历左子树 */ 
      PreOrderTraverse(T->rchild) ; /* 最后先序遍历右子树 */
    }
    ```

    

* 中序遍历

  * 规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结 **点）,**中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。

    ```
    /*二叉树的中序遍历递归算法*/
    void InOrderTraverse (BiTree T )
    {
      if (T==NULL)
        return;
      InOrderTraverse(T->lchild) ; /* 中序遍历左子树 */ 
      printf ( "%c", T->data ) ; /*显示结点数据，可以更改为其他对姑点操作*/ 
      InOrderTraverse(T->rchild) ; /* 最后中序遍历右子树 */
    }
    ```

    

* 后序遍历

  * 规则是若树为空,则空操作返回，否则从左到右先叶子后结点的方式遍历访问左 右子树，最后是访问根结点。

    ```
    /*二又树的后序遍历递归算法*/
    void PostOrderTraverse (BiTree T )
    {
      if (T == NULL )
      	return;
      PostOrderTraverse(T->lchild) ; /* 先后序遍历左子树 */
      PostOrderTraverse(T->rchild) ; /* 再后序遍历右子树 */
      printf ("%c", T->data) ;/*显示节点数据，可以更改为其他对结点操作*/
    }
    ```

* 层序遍历

  * 规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问， 从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。

* 用图形的方式来表现树的结构，应该说是非常直观和容易理解，但是对于计 算机来说，它只有循环、判断等方式来处理，也就是说，它只会处理线性序列，而我 们刚才提到的四种遍历方法，其实都是在把树中的结点变成某种意义的线性序列，这 就给程序的实现带来了好处。另外不同的遍历提供了对结点依次处理的不同方式，可以在遍历过程中对结点进行各种处理。

---

* 推导遍历结果

  ```
  
  ```

* 二叉树遍历的性质
  *  已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
  *  已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。
  * 已知前序和后序遍历，是不能确定一棵二叉树的
    * 前序和后序可以确定跟节点。
    * 中序可以依据元素在跟节点的出现位置判断是否为左右节点

---

* 二叉树的建立

* 为了能让每个结点确认 是否有左右孩子，我们对它进行了扩展，也就是将二叉树中每个结点的空指针引岀一个虚结点，其值为一特定值，比如“#”。我们称这种处理后的二叉树为原二叉树的**扩展二叉树**。扩展二叉树就可以做到一个遍历序列确定一棵 二叉树了。

  ```
  /*按前序输入二叉树中结点的值(一个字符)*/
  /* 表示空树，构造二叉链表表示二叉树T */
  void CreateBiTree ( BiTree *T )
  {
    TElemType ch;
    scanf ( "%c", &ch );
    if ( ch =='#')
      *T = NULL;
    else
    {
    *T= ( BiTree ) malloc ( sizeof ( BiTNode ));
    if ( !*T)
      exit ( OVERFLOW)；
    (*T ) ->data=ch; /* 生成根结点
    CreateBiTree ( & ( *T)->lchild) ; /* 枸造左子树 */ 
    CreateBiTree (& (*T)->rchild) ; /* 构造右子树 */ }
  }
  ```

* 你完全也可以用中序或后序遍历的方式实现二叉树的建立，只不过代码里 生成结点和构造左右子树的代码顺序交换一下。

---

* 线索二叉树

* 在对树做遍历时，得到了树元素的有序序列，遍历过后，我们可以很清楚的知道任意一个结点，它的前驱和后继是哪一个。可是这是建立在已经遍历过的基础之上的。在二叉链表上，我们只能知道每个结点指向其左右孩子结点的地址，而不知道某个结点的前驱是谁，后继是谁。要想知道，必须遍历一次。以后每次需要知道时，都必须先遍历一次。为什么不考虑在创建时就记住这些前驱和后继呢，那将是多大的时间上的节省。

* 指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为**线索二叉树** （Threaded Binary Tree）。

* 对二叉树以某种次序遍历使其变为线索二叉树的过程称做是**线索化**。

* 我们如何知道某一结点的 lchild 是指 向它的左孩子还是指向前驱？ rchild是指向右孩子还是指向后继？我们在决定Ichild是指向左孩子还是前驱，rchild是指向右孩子还是后继上是需要一个区分标志的。因此，我 们在每个结点再增设两个标志域Itag和rtag,注意Itag和rtag只是存放0或1数字的布尔型变量，其占用的内存空间要小于像lchild和rchild的指针变量。

  ```
  //lTag为0时指向该结点的左孩子，为1时指向该结点的前驱。
  //rTag为0时指向该结点的右孩子，为1时指向该结点的后继。
  
  /*二叉树的二叉线索存储结构定义*/
  typedef enum {Link,Thread} PointerTag; 
  /* Link==0 表示指向左右孩子指针 */  /* Thread==l表示指向前驱或后继的线索*/ 
  
  typedef struct BiThrNode /*二叉线索存储结点结构*/
  {
    TElemType data;	/* 结点敬据 */
    struct BiThrNode *lchild, *rchild; /* 左右孩子指针 */
    PointerTag LTag;
    PointerTag RTag;	/* 左右标志 */
  } BiThrNode, *BiThrTree;
  ```

* 线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继的信息只有在遍历该二叉树时才能得到，所以线索化的过程就是在遍历的过程中修改空指针的过程。

  ```
  中序遍历线索化的递归函数代码如下：
  BiThrTree pre; /*全局变量，始终指向刚刚访冋过的结点*/ 
  
  /*中序遍历进行中序线索化*/
  void InThreading (BiThrTree p) (
    if (p)
    {
      InThreading ( p->lchild) ;
      if (!p->lchild) {
      	p->lTag = Thread;
      	p->lchild = pre;
      }
      
        if ( ! pre->rchild )
        {
            pre->RTag = Thread; 
            pre->rchild = p;
        }
    }
  	pre = p;
    InThreading ( p->rchild);
    }
  }
  ```

* 线索二叉树的遍历

  ```
  
  ```

---

* 树的孩子兄弟法可以将一棵树用二叉链表进行 存储，所以借助二叉链表，树和二叉树可以相互进行转换。从物理结构来看，它们的 二叉链表也是相同的，只是解释不太一样而已。因此，只要我们设定一定的规则，用 二叉树来表示树，甚至表示森林都是可以的，森林与二叉树也可以互相进行转换。

* 将树转换为二叉树的步骤如下

  1. 加线。在所有兄弟结点之间加一条连线。

  2. 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩 子结点之间的连线。

  3. 层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构 层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结 点的右孩子。

* 森林转化为二叉树

  * 将各个树转化为二叉树
  * 依次将后一二叉树作为前一二叉树的右子树进行连接

* 二叉树转换为树

  二叉树转换为树是树转换为二叉树的逆过程，也就是反过来做而已。步骤如下：

  1. 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的 右孩子结点、右孩子的右孩子的右孩子结点……，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。

  2. 去线。删除原二叉树中所有结点与其右孩子结点的连线。
  3. 层次调整。使之结构层次分明

* 二叉树转换为森林

  判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是森林，没有就是一棵树。那么如果是转换成森 林，步骤如下：

  1. 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后 的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。
  2. 将每棵分离后的二叉树转换为树即可。

* 树的遍历分为两种方式。

  1. 一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。

  2. 另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点

* 森林的遍历也分为两种方式：

  1. 前序遍历：先访问森林中第一棵树的根结点，然后再依次先根遍历根的每棵子树，再依次用同样方式遍历除去第一棵树的剩余树构成的森林。
  2. 后序遍历：是先访问森林中第一棵树，后根遍历的方式遍历每棵子树，然后再访问根结点，再依次同样方式遍历除去第一棵树的剩余树构成的森林。