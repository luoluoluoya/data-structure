```
/*两栈共享空间结构*/
typedef struct
{
    SElemType data[MAXSIZE];
    int topi; /*栈1栈顶指针*/
    int top2; /*栈2栈顶指针*/
} SqDoubleStack;
```

* 用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也 就是一个栈增长时另一个栈在缩短的情况。这样使用两栈共享 空间存储方法才有比较大的意义。否则两个栈都在不停地增长，那很快就会因栈满而 溢出了。
* 这只是针对两个具有相同数据类型的栈的一个设计上的技巧，如果是不相 同数据类型的栈，这种办法不但不能更好地处理问题，反而会使问题变得更复杂.

---

* 栈的链式存储结构及实现

  * 把栈顶放在单链表的头部
  * 对于链栈来说，基本不存在栈满的情况，除非内存已经没有可以使用的空间，如 果真的发生，那此时的计算机操作系统已经面临死机崩溃的情况，而不是这个链栈是 否溢出的问题。
  * 对于空栈来说，链表原定义是头指针指向空，那么链栈的空其实就是top=NULL 的时候。

  ```
  链栈的结构代码如下：
  typedef struct StackNode
  (
      SElemType data;
      struct StackNode *next;
  } StackNode,*LinkStackPtr;
  
  typedef struct Linkstack
  {
      LinkStackPtr top;
      int count;
  } Linkstack;
  ```

  * 进栈操作

    ```
    /*插入元素e为新的栈顶元素*/
    Status Push ( Linkstack *S, SElemType e)
    (
        LinkStackPtr s= ( LinkStackPtr ) malloc ( sizeof ( StackNode )); 
        s->data=e;
        s->next=S->top;/*把当前的栈顶元素賊值给新结点的直接后继，如图中①•/
        S->top=s; /*将新的结点s赋值给栈顶指针，如图中②*/
        S->count++；
        return OK;
    }
    ```

  * 出栈操作

    ```
    /*若栈不空，则删除S的栈顶元素，用e返回其值，并返回0K;否则返回ERROR */ Status Pop(Linkstack *S,SElemType *e)
    {
        LinkStackPtr p;
        if (StackEmpty ( *S ))
            return ERROR;
        *e=S->top->data;
        p=S->top;	/*将桟顶结点赋值给p,如图③*/
        S->top=S->top->next; /*使得栈顶指针下移一位，指向后一结点，如图④•/ 	   free (p) ;	/* 释放结点 p */
        S->count——;
        return OK;
    }
    ```

*  对比一下顺序栈与链栈，它们在时间复杂度上是一样的，均为0(1)。对于空间性 能，顺序栈需要事先确定一个固定的长度，可能会存在内存空间浪费的问题，它的优势是存取时定位很方便，而链栈则要求每个元素都有指针域，这同时也增加了一些 内存开销，但对于栈的长度无限制。所以它们的区别和线性表中讨论的一样，如果栈 的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之,如果它的变化在可控范围内，建议使用顺序栈会更好一些。

---

* 栈的作用
  * 用数组或链表直接实现功能不就行了吗？干吗要引入栈这 样的数据结构呢？
    
    * 栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。反之，像数组等，因为要分散精力去考虑数组的下标增减等细节问题，反而掩盖了问题的本质。所以现在的许多高级语言，比如Java、C#等都有对栈结构的封装，你可以不用关 注它的实现细节，就可以直接使用Stack的push和pop方法，非常方便。
    
  * 递归
  
    * 递归定义    在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。
    * 写递归程序最怕的就是陷入永不结束的无穷递归中，所以，每个递归定义 必须至少有一个条件，满足时递归不再进行，即不再引用自身而是返回值退出。
    * 迭代和递归的区别是：
      * 迭代使用的是循环结 构，递归使用的是选择结构。
      * 递归能使程序的结构更清晰、更简洁、更容易让人理 解，从而减少读懂代码的时间。
      * 大量的递归调用会建立函数的副本，会耗费大量 的时间和内存。迭代则不需要反复调用函数和占用额外的内存。
    * 递归过程退回的顺序是它前行顺序的逆序。在退回过程中，可能要执行某些动作，包括恢复在前行过程中存储起来的某些数据。
    * 在递归前行阶段，对于每一层递归，函数的局部变量、参数值以及返 回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹 出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。
  
  * 栈的应用一四则运算表达式求值
  
    * 后缀（逆波兰）表示法定义
  
      * 括号都是成对出现的，有左括号就一定会有右括号，对于多 重括号，最终也是完全嵌套匹配的。这用栈结构正好合适，只有碰到左括号，就将此 左括号进栈，不管表达式有多少重括号，反正遇到左括号就进栈，而后面出现右括号 时，就让栈顶的左括号出栈，期间让数字运算，这样，最终有括号的表达式从左到右 巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈的结果。
  
      * 后缀表达式计算结果
  
        ```
        
        ```
  
      * 中缀表达式转后缀表达式
  
        * 规则：从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，即成为后 缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低 于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并将当前符号进栈，一直 到最终输出后缀表达式为止。
  
        ```
        
        ```

---

* 队列的定义

  * 队列(queue )是只允许在一端进行插入操作，而在另一端进行删除操 作的线性表。

  * 队列是一种先进先出(First In First Out)的线性表，简称FIFO。允许插入的一 端称为队尾，允许删除的一端称为队头。

  * 队列的抽象数据类型

    ```
    ADT 队列(Queue)
    Data
        同线性表。元素具有相同的类型，相邻元素具有前曝和后继关系。
    Operation
        InitQueue ( *Q ):初始化操作，建立一个空队列Q。
        DestroyQueue ( *Q):若队列Q存在，则销毁它。
        ClearQueue ( *Q)：将队列 Q 清空。
        QueueEmpty ( Q ):若队列Q为空，返回true,否则返回false。
        GetHead(Q,*e)：若队列Q存在且非空，用e返回队列Q的队头元素。
        EnQueue ( *Q,e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
        DeQueue (*Q,*e):删除队列Q中队头元*,并用e返回其值° 		     QueueLength ( Q):返回队列Q的元素个数
    endADT
    ```

* 队列顺序存储

  * 我们假设一个队列有n个元素，则顺序存储的队列需建立一个大于n的数组，并 把队列的所有元素存储在数组的前n个单元，数组下标为0的一端即是队头。所谓的 入队列操作，其实就是在队尾追加一个元素，不需要移动任何元素，因此时间复杂度为0(1),
  * 与栈不同的是，队列元素的出列是在队头，即下标为0的位置，那也就意味着， 队列中的所有元素都得向前移动，以保证队列的队头，也就是下标为0的位置不为 空，此时时间复杂度为0(n)
  * 如果不去限制队列的元素必须 存储在数组的前n个单元这一条件，出队的性能就会大大增加。也就是说，队头不需 要一定在下标为0的位置
  * 为了避免当只有一个元素时，队头和队尾重合使处理变得麻烦，所以引入两个指 针，front指针指向队头元素，rear指针指向队尾元素的下一个位置，这样当front等 于rear时，此队列不是还剩一个元素，而是空队列。
  * 假设是长度为5的数组，初始状态，空队列，front与 rear指针均指向下标为0的位置。然后入队a1、a2,  a3,  a4, front指针依然指向下标 为0位置，而rear指针指向下标为4的位置.出队a1、a2,则front指针指向下标为2的位置，rear不变。接着入队a6,将它放置于下标为0处，rear指针指向下标为1处。若再入队a7, 则rear指针就与front指针重合，同时指向下标为2的位置.
    * 置一个标志变量flag
    * front = rear,当队列满时，我们修改其条 件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲单元。
  * 假溢出: 因数组末尾元素已经占用，再向后加，就会产生数组越界的错误，可实际上，我们的队列在前端的地方还是空闲的。我们把这种现象叫做“假溢出。解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。 我们把队列的这种头尾相接的顺序存储结构称为循环队列.

  * 循环队列满时的判定公式

    ```
    
    ```

  * 循环队列元素个数的判定公式

    ```
    
    ```

  * 循环队列的顺序存储结构代码如下：

    ```
    typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */ 
    /*循环队列的顺序存储结构*/
    typedef struct
    {
        QElemType data[MAXSIZE];
        int front;/* 头指针 */
        int rear;/*尾指针，若队列不空，指向队列尾元素的下一个位JL */
    
    } SqQueue;
    ```

* 单是顺序存储，若不是循环队列，算法的时间性 能是不高的，但循环队列又面临着数组可能会溢出的问题，所以我们还需要研究一下 不需要担心队列长度的链式存储结构。

---

* 队列的链式存储结构及实现

* 队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已， 我们把它简称为链队列。为了操作上的方便，我们将队头指针指向链队列的头结点，而队尾指针指向终端结点, 空队列时，front和rear都指向头结点

* 链队列的结构为：

  ```
  typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int */
  
  typedef struct QNode /* 结点结构 */
  {
      QElemType data;
      struct QNode *next;
  } QNode,*QueuePtr;
  
  typedef struct	/*队列的链表结构*/
  {
  	QueuePtr front, rear; /* 队头、队尾指卄 */
  } LinkQueue;
  ```

* 队列的链式存储结构——入队操作
  * 入队操作时，其实就是在链表尾部插入结点

* 队列的链式存储结构——出队操作
  * 岀队操作时，就是头结点的后继结点出队，将头结点的后继改为它后面的结点, 若链表除头结点外只剩一个元素时，则需将rear指向头结点

* 对于循环队列与链队列的比较，可以从两方面来考虑，从时间上，其实它们的基 本操作都是常数时间，即都为0(1)的，不过循环队列是事先申请好空间，使用期间不 释放，而对于链队列，每次申请和释放结点也会存在一些时间开销，如果入队出队频 繁，则两者还是有细微差异。对于空间上来说，循环队列必须有一个固定的长度，所 以就有了存储元素个数和空间浪费的问题。而链队列不存在这个问题，尽管它需要一 个指针域，会产生一些空间上的开销，但也可以接受。所以在空间上，链队列更加灵 活。总的来说，在可以确定队列长度最夹值的情况下，建议用循环队列，如果你无法 预估队列的长度时，则用链队列。

---

* 栈和队列，它们都是特殊的线性表， 只不过对插入和删除操作做了限制。
* 栈(stack)是限定仅在表尾进行插入和删除操作的线性表。
* 队列(queue)是只允许在一端进行插入操作，而在另一端进行删除操作的线性 表。
* 它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端。 因此它们各自有各自的技巧来解决这个问题。
  * 对于栈来说，如果是两个相同数据类型的栈，则可以用数组的两端作栈底的方法 来让两个栈共享数据，这就可以最大化地利用数组的空间。
  * 对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队 列，使得队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，使得本来插入和删除是0(n)的时间复杂度变成了 0(1)。
  * 它们也都可以通过链式存储结构来实现，实现原则上与线性表基本相同